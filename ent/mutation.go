// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"github.com/agui-coder/simple-admin-product-rpc/ent/brand"
	"github.com/agui-coder/simple-admin-product-rpc/ent/category"
	"github.com/agui-coder/simple-admin-product-rpc/ent/comment"
	"github.com/agui-coder/simple-admin-product-rpc/ent/predicate"
	"github.com/agui-coder/simple-admin-product-rpc/ent/property"
	"github.com/agui-coder/simple-admin-product-rpc/ent/propertyvalue"
	entType "github.com/agui-coder/simple-admin-product-rpc/ent/schema/enttype"
	"github.com/agui-coder/simple-admin-product-rpc/ent/sku"
	"github.com/agui-coder/simple-admin-product-rpc/ent/spu"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBrand         = "Brand"
	TypeCategory      = "Category"
	TypeComment       = "Comment"
	TypeProperty      = "Property"
	TypePropertyValue = "PropertyValue"
	TypeSku           = "Sku"
	TypeSpu           = "Spu"
)

// BrandMutation represents an operation that mutates the Brand nodes in the graph.
type BrandMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	sort          *uint32
	addsort       *int32
	deleted_at    *time.Time
	name          *string
	pic_url       *string
	description   *string
	clearedFields map[string]struct{}
	spus          map[uint64]struct{}
	removedspus   map[uint64]struct{}
	clearedspus   bool
	done          bool
	oldValue      func(context.Context) (*Brand, error)
	predicates    []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows management of the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for the Brand entity.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the ID field of the mutation.
func withBrandID(id uint64) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Brand entities.
func (m *BrandMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BrandMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Brand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BrandMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BrandMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BrandMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BrandMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BrandMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BrandMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *BrandMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BrandMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *BrandMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BrandMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BrandMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[brand.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BrandMutation) StatusCleared() bool {
	_, ok := m.clearedFields[brand.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BrandMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, brand.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *BrandMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *BrandMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *BrandMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *BrandMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *BrandMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BrandMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BrandMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BrandMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[brand.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BrandMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[brand.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BrandMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, brand.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// SetPicURL sets the "pic_url" field.
func (m *BrandMutation) SetPicURL(s string) {
	m.pic_url = &s
}

// PicURL returns the value of the "pic_url" field in the mutation.
func (m *BrandMutation) PicURL() (r string, exists bool) {
	v := m.pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPicURL returns the old "pic_url" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicURL: %w", err)
	}
	return oldValue.PicURL, nil
}

// ResetPicURL resets all changes to the "pic_url" field.
func (m *BrandMutation) ResetPicURL() {
	m.pic_url = nil
}

// SetDescription sets the "description" field.
func (m *BrandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BrandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BrandMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[brand.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BrandMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[brand.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BrandMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, brand.FieldDescription)
}

// AddSpuIDs adds the "spus" edge to the Spu entity by ids.
func (m *BrandMutation) AddSpuIDs(ids ...uint64) {
	if m.spus == nil {
		m.spus = make(map[uint64]struct{})
	}
	for i := range ids {
		m.spus[ids[i]] = struct{}{}
	}
}

// ClearSpus clears the "spus" edge to the Spu entity.
func (m *BrandMutation) ClearSpus() {
	m.clearedspus = true
}

// SpusCleared reports if the "spus" edge to the Spu entity was cleared.
func (m *BrandMutation) SpusCleared() bool {
	return m.clearedspus
}

// RemoveSpuIDs removes the "spus" edge to the Spu entity by IDs.
func (m *BrandMutation) RemoveSpuIDs(ids ...uint64) {
	if m.removedspus == nil {
		m.removedspus = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.spus, ids[i])
		m.removedspus[ids[i]] = struct{}{}
	}
}

// RemovedSpus returns the removed IDs of the "spus" edge to the Spu entity.
func (m *BrandMutation) RemovedSpusIDs() (ids []uint64) {
	for id := range m.removedspus {
		ids = append(ids, id)
	}
	return
}

// SpusIDs returns the "spus" edge IDs in the mutation.
func (m *BrandMutation) SpusIDs() (ids []uint64) {
	for id := range m.spus {
		ids = append(ids, id)
	}
	return
}

// ResetSpus resets all changes to the "spus" edge.
func (m *BrandMutation) ResetSpus() {
	m.spus = nil
	m.clearedspus = false
	m.removedspus = nil
}

// Where appends a list predicates to the BrandMutation builder.
func (m *BrandMutation) Where(ps ...predicate.Brand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Brand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, brand.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, brand.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, brand.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, brand.FieldSort)
	}
	if m.deleted_at != nil {
		fields = append(fields, brand.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	if m.pic_url != nil {
		fields = append(fields, brand.FieldPicURL)
	}
	if m.description != nil {
		fields = append(fields, brand.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldCreatedAt:
		return m.CreatedAt()
	case brand.FieldUpdatedAt:
		return m.UpdatedAt()
	case brand.FieldStatus:
		return m.Status()
	case brand.FieldSort:
		return m.Sort()
	case brand.FieldDeletedAt:
		return m.DeletedAt()
	case brand.FieldName:
		return m.Name()
	case brand.FieldPicURL:
		return m.PicURL()
	case brand.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case brand.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case brand.FieldStatus:
		return m.OldStatus(ctx)
	case brand.FieldSort:
		return m.OldSort(ctx)
	case brand.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case brand.FieldName:
		return m.OldName(ctx)
	case brand.FieldPicURL:
		return m.OldPicURL(ctx)
	case brand.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case brand.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case brand.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case brand.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case brand.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case brand.FieldPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicURL(v)
		return nil
	case brand.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, brand.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, brand.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldStatus:
		return m.AddedStatus()
	case brand.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case brand.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case brand.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(brand.FieldStatus) {
		fields = append(fields, brand.FieldStatus)
	}
	if m.FieldCleared(brand.FieldDeletedAt) {
		fields = append(fields, brand.FieldDeletedAt)
	}
	if m.FieldCleared(brand.FieldDescription) {
		fields = append(fields, brand.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	switch name {
	case brand.FieldStatus:
		m.ClearStatus()
		return nil
	case brand.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case brand.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case brand.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case brand.FieldStatus:
		m.ResetStatus()
		return nil
	case brand.FieldSort:
		m.ResetSort()
		return nil
	case brand.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case brand.FieldName:
		m.ResetName()
		return nil
	case brand.FieldPicURL:
		m.ResetPicURL()
		return nil
	case brand.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spus != nil {
		edges = append(edges, brand.EdgeSpus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeSpus:
		ids := make([]ent.Value, 0, len(m.spus))
		for id := range m.spus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspus != nil {
		edges = append(edges, brand.EdgeSpus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeSpus:
		ids := make([]ent.Value, 0, len(m.removedspus))
		for id := range m.removedspus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspus {
		edges = append(edges, brand.EdgeSpus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeSpus:
		return m.clearedspus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeSpus:
		m.ResetSpus()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	status          *uint8
	addstatus       *int8
	sort            *uint32
	addsort         *int32
	deleted_at      *time.Time
	name            *string
	pic_url         *string
	big_pic_url     *string
	clearedFields   map[string]struct{}
	spus            map[uint64]struct{}
	removedspus     map[uint64]struct{}
	clearedspus     bool
	parent          *uint64
	clearedparent   bool
	children        map[uint64]struct{}
	removedchildren map[uint64]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id uint64) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *CategoryMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CategoryMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CategoryMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CategoryMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CategoryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[category.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CategoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[category.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CategoryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, category.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *CategoryMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *CategoryMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *CategoryMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *CategoryMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *CategoryMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[category.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, category.FieldDeletedAt)
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, category.FieldParentID)
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetPicURL sets the "pic_url" field.
func (m *CategoryMutation) SetPicURL(s string) {
	m.pic_url = &s
}

// PicURL returns the value of the "pic_url" field in the mutation.
func (m *CategoryMutation) PicURL() (r string, exists bool) {
	v := m.pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPicURL returns the old "pic_url" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicURL: %w", err)
	}
	return oldValue.PicURL, nil
}

// ResetPicURL resets all changes to the "pic_url" field.
func (m *CategoryMutation) ResetPicURL() {
	m.pic_url = nil
}

// SetBigPicURL sets the "big_pic_url" field.
func (m *CategoryMutation) SetBigPicURL(s string) {
	m.big_pic_url = &s
}

// BigPicURL returns the value of the "big_pic_url" field in the mutation.
func (m *CategoryMutation) BigPicURL() (r string, exists bool) {
	v := m.big_pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBigPicURL returns the old "big_pic_url" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldBigPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBigPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBigPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBigPicURL: %w", err)
	}
	return oldValue.BigPicURL, nil
}

// ClearBigPicURL clears the value of the "big_pic_url" field.
func (m *CategoryMutation) ClearBigPicURL() {
	m.big_pic_url = nil
	m.clearedFields[category.FieldBigPicURL] = struct{}{}
}

// BigPicURLCleared returns if the "big_pic_url" field was cleared in this mutation.
func (m *CategoryMutation) BigPicURLCleared() bool {
	_, ok := m.clearedFields[category.FieldBigPicURL]
	return ok
}

// ResetBigPicURL resets all changes to the "big_pic_url" field.
func (m *CategoryMutation) ResetBigPicURL() {
	m.big_pic_url = nil
	delete(m.clearedFields, category.FieldBigPicURL)
}

// AddSpuIDs adds the "spus" edge to the Spu entity by ids.
func (m *CategoryMutation) AddSpuIDs(ids ...uint64) {
	if m.spus == nil {
		m.spus = make(map[uint64]struct{})
	}
	for i := range ids {
		m.spus[ids[i]] = struct{}{}
	}
}

// ClearSpus clears the "spus" edge to the Spu entity.
func (m *CategoryMutation) ClearSpus() {
	m.clearedspus = true
}

// SpusCleared reports if the "spus" edge to the Spu entity was cleared.
func (m *CategoryMutation) SpusCleared() bool {
	return m.clearedspus
}

// RemoveSpuIDs removes the "spus" edge to the Spu entity by IDs.
func (m *CategoryMutation) RemoveSpuIDs(ids ...uint64) {
	if m.removedspus == nil {
		m.removedspus = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.spus, ids[i])
		m.removedspus[ids[i]] = struct{}{}
	}
}

// RemovedSpus returns the removed IDs of the "spus" edge to the Spu entity.
func (m *CategoryMutation) RemovedSpusIDs() (ids []uint64) {
	for id := range m.removedspus {
		ids = append(ids, id)
	}
	return
}

// SpusIDs returns the "spus" edge IDs in the mutation.
func (m *CategoryMutation) SpusIDs() (ids []uint64) {
	for id := range m.spus {
		ids = append(ids, id)
	}
	return
}

// ResetSpus resets all changes to the "spus" edge.
func (m *CategoryMutation) ResetSpus() {
	m.spus = nil
	m.clearedspus = false
	m.removedspus = nil
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, category.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, category.FieldSort)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.pic_url != nil {
		fields = append(fields, category.FieldPicURL)
	}
	if m.big_pic_url != nil {
		fields = append(fields, category.FieldBigPicURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldStatus:
		return m.Status()
	case category.FieldSort:
		return m.Sort()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldName:
		return m.Name()
	case category.FieldPicURL:
		return m.PicURL()
	case category.FieldBigPicURL:
		return m.BigPicURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldStatus:
		return m.OldStatus(ctx)
	case category.FieldSort:
		return m.OldSort(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldPicURL:
		return m.OldPicURL(ctx)
	case category.FieldBigPicURL:
		return m.OldBigPicURL(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case category.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicURL(v)
		return nil
	case category.FieldBigPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBigPicURL(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, category.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, category.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldStatus:
		return m.AddedStatus()
	case category.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case category.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldStatus) {
		fields = append(fields, category.FieldStatus)
	}
	if m.FieldCleared(category.FieldDeletedAt) {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	if m.FieldCleared(category.FieldBigPicURL) {
		fields = append(fields, category.FieldBigPicURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldStatus:
		m.ClearStatus()
		return nil
	case category.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	case category.FieldBigPicURL:
		m.ClearBigPicURL()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldStatus:
		m.ResetStatus()
		return nil
	case category.FieldSort:
		m.ResetSort()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldPicURL:
		m.ResetPicURL()
		return nil
	case category.FieldBigPicURL:
		m.ResetBigPicURL()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.spus != nil {
		edges = append(edges, category.EdgeSpus)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeSpus:
		ids := make([]ent.Value, 0, len(m.spus))
		for id := range m.spus {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedspus != nil {
		edges = append(edges, category.EdgeSpus)
	}
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeSpus:
		ids := make([]ent.Value, 0, len(m.removedspus))
		for id := range m.removedspus {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedspus {
		edges = append(edges, category.EdgeSpus)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeSpus:
		return m.clearedspus
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeSpus:
		m.ResetSpus()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	user_id               *uint64
	adduser_id            *int64
	user_nickname         *string
	user_avatar           *string
	anonymous             *bool
	order_id              *uint64
	addorder_id           *int64
	order_item_id         *uint64
	addorder_item_id      *int64
	spu_id                *uint64
	addspu_id             *int64
	spu_name              *string
	sku_pic_url           *string
	sku_properties        *[]entType.SkuProperty
	appendsku_properties  []entType.SkuProperty
	visible               *bool
	scores                *int8
	addscores             *int8
	description_scores    *int8
	adddescription_scores *int8
	benefit_scores        *int8
	addbenefit_scores     *int8
	content               *string
	pic_urls              *string
	reply_status          *bool
	reply_user_id         *int
	addreply_user_id      *int
	reply_content         *string
	reply_time            *time.Time
	clearedFields         map[string]struct{}
	skus                  *uint64
	clearedskus           bool
	done                  bool
	oldValue              func(context.Context) (*Comment, error)
	predicates            []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uint64) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[comment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, comment.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *CommentMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CommentMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *CommentMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CommentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, comment.FieldUserID)
}

// SetUserNickname sets the "user_nickname" field.
func (m *CommentMutation) SetUserNickname(s string) {
	m.user_nickname = &s
}

// UserNickname returns the value of the "user_nickname" field in the mutation.
func (m *CommentMutation) UserNickname() (r string, exists bool) {
	v := m.user_nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldUserNickname returns the old "user_nickname" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserNickname: %w", err)
	}
	return oldValue.UserNickname, nil
}

// ClearUserNickname clears the value of the "user_nickname" field.
func (m *CommentMutation) ClearUserNickname() {
	m.user_nickname = nil
	m.clearedFields[comment.FieldUserNickname] = struct{}{}
}

// UserNicknameCleared returns if the "user_nickname" field was cleared in this mutation.
func (m *CommentMutation) UserNicknameCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserNickname]
	return ok
}

// ResetUserNickname resets all changes to the "user_nickname" field.
func (m *CommentMutation) ResetUserNickname() {
	m.user_nickname = nil
	delete(m.clearedFields, comment.FieldUserNickname)
}

// SetUserAvatar sets the "user_avatar" field.
func (m *CommentMutation) SetUserAvatar(s string) {
	m.user_avatar = &s
}

// UserAvatar returns the value of the "user_avatar" field in the mutation.
func (m *CommentMutation) UserAvatar() (r string, exists bool) {
	v := m.user_avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAvatar returns the old "user_avatar" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAvatar: %w", err)
	}
	return oldValue.UserAvatar, nil
}

// ClearUserAvatar clears the value of the "user_avatar" field.
func (m *CommentMutation) ClearUserAvatar() {
	m.user_avatar = nil
	m.clearedFields[comment.FieldUserAvatar] = struct{}{}
}

// UserAvatarCleared returns if the "user_avatar" field was cleared in this mutation.
func (m *CommentMutation) UserAvatarCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserAvatar]
	return ok
}

// ResetUserAvatar resets all changes to the "user_avatar" field.
func (m *CommentMutation) ResetUserAvatar() {
	m.user_avatar = nil
	delete(m.clearedFields, comment.FieldUserAvatar)
}

// SetAnonymous sets the "anonymous" field.
func (m *CommentMutation) SetAnonymous(b bool) {
	m.anonymous = &b
}

// Anonymous returns the value of the "anonymous" field in the mutation.
func (m *CommentMutation) Anonymous() (r bool, exists bool) {
	v := m.anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldAnonymous returns the old "anonymous" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnonymous: %w", err)
	}
	return oldValue.Anonymous, nil
}

// ClearAnonymous clears the value of the "anonymous" field.
func (m *CommentMutation) ClearAnonymous() {
	m.anonymous = nil
	m.clearedFields[comment.FieldAnonymous] = struct{}{}
}

// AnonymousCleared returns if the "anonymous" field was cleared in this mutation.
func (m *CommentMutation) AnonymousCleared() bool {
	_, ok := m.clearedFields[comment.FieldAnonymous]
	return ok
}

// ResetAnonymous resets all changes to the "anonymous" field.
func (m *CommentMutation) ResetAnonymous() {
	m.anonymous = nil
	delete(m.clearedFields, comment.FieldAnonymous)
}

// SetOrderID sets the "order_id" field.
func (m *CommentMutation) SetOrderID(u uint64) {
	m.order_id = &u
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CommentMutation) OrderID() (r uint64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds u to the "order_id" field.
func (m *CommentMutation) AddOrderID(u int64) {
	if m.addorder_id != nil {
		*m.addorder_id += u
	} else {
		m.addorder_id = &u
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *CommentMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *CommentMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[comment.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *CommentMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CommentMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, comment.FieldOrderID)
}

// SetOrderItemID sets the "order_item_id" field.
func (m *CommentMutation) SetOrderItemID(u uint64) {
	m.order_item_id = &u
	m.addorder_item_id = nil
}

// OrderItemID returns the value of the "order_item_id" field in the mutation.
func (m *CommentMutation) OrderItemID() (r uint64, exists bool) {
	v := m.order_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemID returns the old "order_item_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldOrderItemID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemID: %w", err)
	}
	return oldValue.OrderItemID, nil
}

// AddOrderItemID adds u to the "order_item_id" field.
func (m *CommentMutation) AddOrderItemID(u int64) {
	if m.addorder_item_id != nil {
		*m.addorder_item_id += u
	} else {
		m.addorder_item_id = &u
	}
}

// AddedOrderItemID returns the value that was added to the "order_item_id" field in this mutation.
func (m *CommentMutation) AddedOrderItemID() (r int64, exists bool) {
	v := m.addorder_item_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderItemID clears the value of the "order_item_id" field.
func (m *CommentMutation) ClearOrderItemID() {
	m.order_item_id = nil
	m.addorder_item_id = nil
	m.clearedFields[comment.FieldOrderItemID] = struct{}{}
}

// OrderItemIDCleared returns if the "order_item_id" field was cleared in this mutation.
func (m *CommentMutation) OrderItemIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldOrderItemID]
	return ok
}

// ResetOrderItemID resets all changes to the "order_item_id" field.
func (m *CommentMutation) ResetOrderItemID() {
	m.order_item_id = nil
	m.addorder_item_id = nil
	delete(m.clearedFields, comment.FieldOrderItemID)
}

// SetSpuID sets the "spu_id" field.
func (m *CommentMutation) SetSpuID(u uint64) {
	m.spu_id = &u
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *CommentMutation) SpuID() (r uint64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldSpuID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds u to the "spu_id" field.
func (m *CommentMutation) AddSpuID(u int64) {
	if m.addspu_id != nil {
		*m.addspu_id += u
	} else {
		m.addspu_id = &u
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *CommentMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *CommentMutation) ClearSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
	m.clearedFields[comment.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *CommentMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *CommentMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
	delete(m.clearedFields, comment.FieldSpuID)
}

// SetSpuName sets the "spu_name" field.
func (m *CommentMutation) SetSpuName(s string) {
	m.spu_name = &s
}

// SpuName returns the value of the "spu_name" field in the mutation.
func (m *CommentMutation) SpuName() (r string, exists bool) {
	v := m.spu_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuName returns the old "spu_name" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldSpuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuName: %w", err)
	}
	return oldValue.SpuName, nil
}

// ClearSpuName clears the value of the "spu_name" field.
func (m *CommentMutation) ClearSpuName() {
	m.spu_name = nil
	m.clearedFields[comment.FieldSpuName] = struct{}{}
}

// SpuNameCleared returns if the "spu_name" field was cleared in this mutation.
func (m *CommentMutation) SpuNameCleared() bool {
	_, ok := m.clearedFields[comment.FieldSpuName]
	return ok
}

// ResetSpuName resets all changes to the "spu_name" field.
func (m *CommentMutation) ResetSpuName() {
	m.spu_name = nil
	delete(m.clearedFields, comment.FieldSpuName)
}

// SetSkuID sets the "sku_id" field.
func (m *CommentMutation) SetSkuID(u uint64) {
	m.skus = &u
}

// SkuID returns the value of the "sku_id" field in the mutation.
func (m *CommentMutation) SkuID() (r uint64, exists bool) {
	v := m.skus
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuID returns the old "sku_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldSkuID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuID: %w", err)
	}
	return oldValue.SkuID, nil
}

// ClearSkuID clears the value of the "sku_id" field.
func (m *CommentMutation) ClearSkuID() {
	m.skus = nil
	m.clearedFields[comment.FieldSkuID] = struct{}{}
}

// SkuIDCleared returns if the "sku_id" field was cleared in this mutation.
func (m *CommentMutation) SkuIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldSkuID]
	return ok
}

// ResetSkuID resets all changes to the "sku_id" field.
func (m *CommentMutation) ResetSkuID() {
	m.skus = nil
	delete(m.clearedFields, comment.FieldSkuID)
}

// SetSkuPicURL sets the "sku_pic_url" field.
func (m *CommentMutation) SetSkuPicURL(s string) {
	m.sku_pic_url = &s
}

// SkuPicURL returns the value of the "sku_pic_url" field in the mutation.
func (m *CommentMutation) SkuPicURL() (r string, exists bool) {
	v := m.sku_pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuPicURL returns the old "sku_pic_url" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldSkuPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkuPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkuPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuPicURL: %w", err)
	}
	return oldValue.SkuPicURL, nil
}

// ResetSkuPicURL resets all changes to the "sku_pic_url" field.
func (m *CommentMutation) ResetSkuPicURL() {
	m.sku_pic_url = nil
}

// SetSkuProperties sets the "sku_properties" field.
func (m *CommentMutation) SetSkuProperties(etp []entType.SkuProperty) {
	m.sku_properties = &etp
	m.appendsku_properties = nil
}

// SkuProperties returns the value of the "sku_properties" field in the mutation.
func (m *CommentMutation) SkuProperties() (r []entType.SkuProperty, exists bool) {
	v := m.sku_properties
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuProperties returns the old "sku_properties" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldSkuProperties(ctx context.Context) (v []entType.SkuProperty, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkuProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkuProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuProperties: %w", err)
	}
	return oldValue.SkuProperties, nil
}

// AppendSkuProperties adds etp to the "sku_properties" field.
func (m *CommentMutation) AppendSkuProperties(etp []entType.SkuProperty) {
	m.appendsku_properties = append(m.appendsku_properties, etp...)
}

// AppendedSkuProperties returns the list of values that were appended to the "sku_properties" field in this mutation.
func (m *CommentMutation) AppendedSkuProperties() ([]entType.SkuProperty, bool) {
	if len(m.appendsku_properties) == 0 {
		return nil, false
	}
	return m.appendsku_properties, true
}

// ClearSkuProperties clears the value of the "sku_properties" field.
func (m *CommentMutation) ClearSkuProperties() {
	m.sku_properties = nil
	m.appendsku_properties = nil
	m.clearedFields[comment.FieldSkuProperties] = struct{}{}
}

// SkuPropertiesCleared returns if the "sku_properties" field was cleared in this mutation.
func (m *CommentMutation) SkuPropertiesCleared() bool {
	_, ok := m.clearedFields[comment.FieldSkuProperties]
	return ok
}

// ResetSkuProperties resets all changes to the "sku_properties" field.
func (m *CommentMutation) ResetSkuProperties() {
	m.sku_properties = nil
	m.appendsku_properties = nil
	delete(m.clearedFields, comment.FieldSkuProperties)
}

// SetVisible sets the "visible" field.
func (m *CommentMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *CommentMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ClearVisible clears the value of the "visible" field.
func (m *CommentMutation) ClearVisible() {
	m.visible = nil
	m.clearedFields[comment.FieldVisible] = struct{}{}
}

// VisibleCleared returns if the "visible" field was cleared in this mutation.
func (m *CommentMutation) VisibleCleared() bool {
	_, ok := m.clearedFields[comment.FieldVisible]
	return ok
}

// ResetVisible resets all changes to the "visible" field.
func (m *CommentMutation) ResetVisible() {
	m.visible = nil
	delete(m.clearedFields, comment.FieldVisible)
}

// SetScores sets the "scores" field.
func (m *CommentMutation) SetScores(i int8) {
	m.scores = &i
	m.addscores = nil
}

// Scores returns the value of the "scores" field in the mutation.
func (m *CommentMutation) Scores() (r int8, exists bool) {
	v := m.scores
	if v == nil {
		return
	}
	return *v, true
}

// OldScores returns the old "scores" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldScores(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScores: %w", err)
	}
	return oldValue.Scores, nil
}

// AddScores adds i to the "scores" field.
func (m *CommentMutation) AddScores(i int8) {
	if m.addscores != nil {
		*m.addscores += i
	} else {
		m.addscores = &i
	}
}

// AddedScores returns the value that was added to the "scores" field in this mutation.
func (m *CommentMutation) AddedScores() (r int8, exists bool) {
	v := m.addscores
	if v == nil {
		return
	}
	return *v, true
}

// ClearScores clears the value of the "scores" field.
func (m *CommentMutation) ClearScores() {
	m.scores = nil
	m.addscores = nil
	m.clearedFields[comment.FieldScores] = struct{}{}
}

// ScoresCleared returns if the "scores" field was cleared in this mutation.
func (m *CommentMutation) ScoresCleared() bool {
	_, ok := m.clearedFields[comment.FieldScores]
	return ok
}

// ResetScores resets all changes to the "scores" field.
func (m *CommentMutation) ResetScores() {
	m.scores = nil
	m.addscores = nil
	delete(m.clearedFields, comment.FieldScores)
}

// SetDescriptionScores sets the "description_scores" field.
func (m *CommentMutation) SetDescriptionScores(i int8) {
	m.description_scores = &i
	m.adddescription_scores = nil
}

// DescriptionScores returns the value of the "description_scores" field in the mutation.
func (m *CommentMutation) DescriptionScores() (r int8, exists bool) {
	v := m.description_scores
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptionScores returns the old "description_scores" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDescriptionScores(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescriptionScores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescriptionScores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptionScores: %w", err)
	}
	return oldValue.DescriptionScores, nil
}

// AddDescriptionScores adds i to the "description_scores" field.
func (m *CommentMutation) AddDescriptionScores(i int8) {
	if m.adddescription_scores != nil {
		*m.adddescription_scores += i
	} else {
		m.adddescription_scores = &i
	}
}

// AddedDescriptionScores returns the value that was added to the "description_scores" field in this mutation.
func (m *CommentMutation) AddedDescriptionScores() (r int8, exists bool) {
	v := m.adddescription_scores
	if v == nil {
		return
	}
	return *v, true
}

// ClearDescriptionScores clears the value of the "description_scores" field.
func (m *CommentMutation) ClearDescriptionScores() {
	m.description_scores = nil
	m.adddescription_scores = nil
	m.clearedFields[comment.FieldDescriptionScores] = struct{}{}
}

// DescriptionScoresCleared returns if the "description_scores" field was cleared in this mutation.
func (m *CommentMutation) DescriptionScoresCleared() bool {
	_, ok := m.clearedFields[comment.FieldDescriptionScores]
	return ok
}

// ResetDescriptionScores resets all changes to the "description_scores" field.
func (m *CommentMutation) ResetDescriptionScores() {
	m.description_scores = nil
	m.adddescription_scores = nil
	delete(m.clearedFields, comment.FieldDescriptionScores)
}

// SetBenefitScores sets the "benefit_scores" field.
func (m *CommentMutation) SetBenefitScores(i int8) {
	m.benefit_scores = &i
	m.addbenefit_scores = nil
}

// BenefitScores returns the value of the "benefit_scores" field in the mutation.
func (m *CommentMutation) BenefitScores() (r int8, exists bool) {
	v := m.benefit_scores
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitScores returns the old "benefit_scores" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldBenefitScores(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitScores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitScores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitScores: %w", err)
	}
	return oldValue.BenefitScores, nil
}

// AddBenefitScores adds i to the "benefit_scores" field.
func (m *CommentMutation) AddBenefitScores(i int8) {
	if m.addbenefit_scores != nil {
		*m.addbenefit_scores += i
	} else {
		m.addbenefit_scores = &i
	}
}

// AddedBenefitScores returns the value that was added to the "benefit_scores" field in this mutation.
func (m *CommentMutation) AddedBenefitScores() (r int8, exists bool) {
	v := m.addbenefit_scores
	if v == nil {
		return
	}
	return *v, true
}

// ClearBenefitScores clears the value of the "benefit_scores" field.
func (m *CommentMutation) ClearBenefitScores() {
	m.benefit_scores = nil
	m.addbenefit_scores = nil
	m.clearedFields[comment.FieldBenefitScores] = struct{}{}
}

// BenefitScoresCleared returns if the "benefit_scores" field was cleared in this mutation.
func (m *CommentMutation) BenefitScoresCleared() bool {
	_, ok := m.clearedFields[comment.FieldBenefitScores]
	return ok
}

// ResetBenefitScores resets all changes to the "benefit_scores" field.
func (m *CommentMutation) ResetBenefitScores() {
	m.benefit_scores = nil
	m.addbenefit_scores = nil
	delete(m.clearedFields, comment.FieldBenefitScores)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[comment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[comment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, comment.FieldContent)
}

// SetPicUrls sets the "pic_urls" field.
func (m *CommentMutation) SetPicUrls(s string) {
	m.pic_urls = &s
}

// PicUrls returns the value of the "pic_urls" field in the mutation.
func (m *CommentMutation) PicUrls() (r string, exists bool) {
	v := m.pic_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldPicUrls returns the old "pic_urls" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPicUrls(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicUrls: %w", err)
	}
	return oldValue.PicUrls, nil
}

// ClearPicUrls clears the value of the "pic_urls" field.
func (m *CommentMutation) ClearPicUrls() {
	m.pic_urls = nil
	m.clearedFields[comment.FieldPicUrls] = struct{}{}
}

// PicUrlsCleared returns if the "pic_urls" field was cleared in this mutation.
func (m *CommentMutation) PicUrlsCleared() bool {
	_, ok := m.clearedFields[comment.FieldPicUrls]
	return ok
}

// ResetPicUrls resets all changes to the "pic_urls" field.
func (m *CommentMutation) ResetPicUrls() {
	m.pic_urls = nil
	delete(m.clearedFields, comment.FieldPicUrls)
}

// SetReplyStatus sets the "reply_status" field.
func (m *CommentMutation) SetReplyStatus(b bool) {
	m.reply_status = &b
}

// ReplyStatus returns the value of the "reply_status" field in the mutation.
func (m *CommentMutation) ReplyStatus() (r bool, exists bool) {
	v := m.reply_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyStatus returns the old "reply_status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyStatus: %w", err)
	}
	return oldValue.ReplyStatus, nil
}

// ClearReplyStatus clears the value of the "reply_status" field.
func (m *CommentMutation) ClearReplyStatus() {
	m.reply_status = nil
	m.clearedFields[comment.FieldReplyStatus] = struct{}{}
}

// ReplyStatusCleared returns if the "reply_status" field was cleared in this mutation.
func (m *CommentMutation) ReplyStatusCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyStatus]
	return ok
}

// ResetReplyStatus resets all changes to the "reply_status" field.
func (m *CommentMutation) ResetReplyStatus() {
	m.reply_status = nil
	delete(m.clearedFields, comment.FieldReplyStatus)
}

// SetReplyUserID sets the "reply_user_id" field.
func (m *CommentMutation) SetReplyUserID(i int) {
	m.reply_user_id = &i
	m.addreply_user_id = nil
}

// ReplyUserID returns the value of the "reply_user_id" field in the mutation.
func (m *CommentMutation) ReplyUserID() (r int, exists bool) {
	v := m.reply_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyUserID returns the old "reply_user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyUserID: %w", err)
	}
	return oldValue.ReplyUserID, nil
}

// AddReplyUserID adds i to the "reply_user_id" field.
func (m *CommentMutation) AddReplyUserID(i int) {
	if m.addreply_user_id != nil {
		*m.addreply_user_id += i
	} else {
		m.addreply_user_id = &i
	}
}

// AddedReplyUserID returns the value that was added to the "reply_user_id" field in this mutation.
func (m *CommentMutation) AddedReplyUserID() (r int, exists bool) {
	v := m.addreply_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplyUserID clears the value of the "reply_user_id" field.
func (m *CommentMutation) ClearReplyUserID() {
	m.reply_user_id = nil
	m.addreply_user_id = nil
	m.clearedFields[comment.FieldReplyUserID] = struct{}{}
}

// ReplyUserIDCleared returns if the "reply_user_id" field was cleared in this mutation.
func (m *CommentMutation) ReplyUserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyUserID]
	return ok
}

// ResetReplyUserID resets all changes to the "reply_user_id" field.
func (m *CommentMutation) ResetReplyUserID() {
	m.reply_user_id = nil
	m.addreply_user_id = nil
	delete(m.clearedFields, comment.FieldReplyUserID)
}

// SetReplyContent sets the "reply_content" field.
func (m *CommentMutation) SetReplyContent(s string) {
	m.reply_content = &s
}

// ReplyContent returns the value of the "reply_content" field in the mutation.
func (m *CommentMutation) ReplyContent() (r string, exists bool) {
	v := m.reply_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyContent returns the old "reply_content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyContent: %w", err)
	}
	return oldValue.ReplyContent, nil
}

// ClearReplyContent clears the value of the "reply_content" field.
func (m *CommentMutation) ClearReplyContent() {
	m.reply_content = nil
	m.clearedFields[comment.FieldReplyContent] = struct{}{}
}

// ReplyContentCleared returns if the "reply_content" field was cleared in this mutation.
func (m *CommentMutation) ReplyContentCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyContent]
	return ok
}

// ResetReplyContent resets all changes to the "reply_content" field.
func (m *CommentMutation) ResetReplyContent() {
	m.reply_content = nil
	delete(m.clearedFields, comment.FieldReplyContent)
}

// SetReplyTime sets the "reply_time" field.
func (m *CommentMutation) SetReplyTime(t time.Time) {
	m.reply_time = &t
}

// ReplyTime returns the value of the "reply_time" field in the mutation.
func (m *CommentMutation) ReplyTime() (r time.Time, exists bool) {
	v := m.reply_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyTime returns the old "reply_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyTime: %w", err)
	}
	return oldValue.ReplyTime, nil
}

// ClearReplyTime clears the value of the "reply_time" field.
func (m *CommentMutation) ClearReplyTime() {
	m.reply_time = nil
	m.clearedFields[comment.FieldReplyTime] = struct{}{}
}

// ReplyTimeCleared returns if the "reply_time" field was cleared in this mutation.
func (m *CommentMutation) ReplyTimeCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyTime]
	return ok
}

// ResetReplyTime resets all changes to the "reply_time" field.
func (m *CommentMutation) ResetReplyTime() {
	m.reply_time = nil
	delete(m.clearedFields, comment.FieldReplyTime)
}

// SetSkusID sets the "skus" edge to the Sku entity by id.
func (m *CommentMutation) SetSkusID(id uint64) {
	m.skus = &id
}

// ClearSkus clears the "skus" edge to the Sku entity.
func (m *CommentMutation) ClearSkus() {
	m.clearedskus = true
	m.clearedFields[comment.FieldSkuID] = struct{}{}
}

// SkusCleared reports if the "skus" edge to the Sku entity was cleared.
func (m *CommentMutation) SkusCleared() bool {
	return m.SkuIDCleared() || m.clearedskus
}

// SkusID returns the "skus" edge ID in the mutation.
func (m *CommentMutation) SkusID() (id uint64, exists bool) {
	if m.skus != nil {
		return *m.skus, true
	}
	return
}

// SkusIDs returns the "skus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkusID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) SkusIDs() (ids []uint64) {
	if id := m.skus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkus resets all changes to the "skus" edge.
func (m *CommentMutation) ResetSkus() {
	m.skus = nil
	m.clearedskus = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.user_nickname != nil {
		fields = append(fields, comment.FieldUserNickname)
	}
	if m.user_avatar != nil {
		fields = append(fields, comment.FieldUserAvatar)
	}
	if m.anonymous != nil {
		fields = append(fields, comment.FieldAnonymous)
	}
	if m.order_id != nil {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.order_item_id != nil {
		fields = append(fields, comment.FieldOrderItemID)
	}
	if m.spu_id != nil {
		fields = append(fields, comment.FieldSpuID)
	}
	if m.spu_name != nil {
		fields = append(fields, comment.FieldSpuName)
	}
	if m.skus != nil {
		fields = append(fields, comment.FieldSkuID)
	}
	if m.sku_pic_url != nil {
		fields = append(fields, comment.FieldSkuPicURL)
	}
	if m.sku_properties != nil {
		fields = append(fields, comment.FieldSkuProperties)
	}
	if m.visible != nil {
		fields = append(fields, comment.FieldVisible)
	}
	if m.scores != nil {
		fields = append(fields, comment.FieldScores)
	}
	if m.description_scores != nil {
		fields = append(fields, comment.FieldDescriptionScores)
	}
	if m.benefit_scores != nil {
		fields = append(fields, comment.FieldBenefitScores)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.pic_urls != nil {
		fields = append(fields, comment.FieldPicUrls)
	}
	if m.reply_status != nil {
		fields = append(fields, comment.FieldReplyStatus)
	}
	if m.reply_user_id != nil {
		fields = append(fields, comment.FieldReplyUserID)
	}
	if m.reply_content != nil {
		fields = append(fields, comment.FieldReplyContent)
	}
	if m.reply_time != nil {
		fields = append(fields, comment.FieldReplyTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldUserNickname:
		return m.UserNickname()
	case comment.FieldUserAvatar:
		return m.UserAvatar()
	case comment.FieldAnonymous:
		return m.Anonymous()
	case comment.FieldOrderID:
		return m.OrderID()
	case comment.FieldOrderItemID:
		return m.OrderItemID()
	case comment.FieldSpuID:
		return m.SpuID()
	case comment.FieldSpuName:
		return m.SpuName()
	case comment.FieldSkuID:
		return m.SkuID()
	case comment.FieldSkuPicURL:
		return m.SkuPicURL()
	case comment.FieldSkuProperties:
		return m.SkuProperties()
	case comment.FieldVisible:
		return m.Visible()
	case comment.FieldScores:
		return m.Scores()
	case comment.FieldDescriptionScores:
		return m.DescriptionScores()
	case comment.FieldBenefitScores:
		return m.BenefitScores()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldPicUrls:
		return m.PicUrls()
	case comment.FieldReplyStatus:
		return m.ReplyStatus()
	case comment.FieldReplyUserID:
		return m.ReplyUserID()
	case comment.FieldReplyContent:
		return m.ReplyContent()
	case comment.FieldReplyTime:
		return m.ReplyTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldUserNickname:
		return m.OldUserNickname(ctx)
	case comment.FieldUserAvatar:
		return m.OldUserAvatar(ctx)
	case comment.FieldAnonymous:
		return m.OldAnonymous(ctx)
	case comment.FieldOrderID:
		return m.OldOrderID(ctx)
	case comment.FieldOrderItemID:
		return m.OldOrderItemID(ctx)
	case comment.FieldSpuID:
		return m.OldSpuID(ctx)
	case comment.FieldSpuName:
		return m.OldSpuName(ctx)
	case comment.FieldSkuID:
		return m.OldSkuID(ctx)
	case comment.FieldSkuPicURL:
		return m.OldSkuPicURL(ctx)
	case comment.FieldSkuProperties:
		return m.OldSkuProperties(ctx)
	case comment.FieldVisible:
		return m.OldVisible(ctx)
	case comment.FieldScores:
		return m.OldScores(ctx)
	case comment.FieldDescriptionScores:
		return m.OldDescriptionScores(ctx)
	case comment.FieldBenefitScores:
		return m.OldBenefitScores(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldPicUrls:
		return m.OldPicUrls(ctx)
	case comment.FieldReplyStatus:
		return m.OldReplyStatus(ctx)
	case comment.FieldReplyUserID:
		return m.OldReplyUserID(ctx)
	case comment.FieldReplyContent:
		return m.OldReplyContent(ctx)
	case comment.FieldReplyTime:
		return m.OldReplyTime(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldUserNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserNickname(v)
		return nil
	case comment.FieldUserAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAvatar(v)
		return nil
	case comment.FieldAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnonymous(v)
		return nil
	case comment.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case comment.FieldOrderItemID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemID(v)
		return nil
	case comment.FieldSpuID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case comment.FieldSpuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuName(v)
		return nil
	case comment.FieldSkuID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuID(v)
		return nil
	case comment.FieldSkuPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuPicURL(v)
		return nil
	case comment.FieldSkuProperties:
		v, ok := value.([]entType.SkuProperty)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuProperties(v)
		return nil
	case comment.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case comment.FieldScores:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScores(v)
		return nil
	case comment.FieldDescriptionScores:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptionScores(v)
		return nil
	case comment.FieldBenefitScores:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitScores(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldPicUrls:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicUrls(v)
		return nil
	case comment.FieldReplyStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyStatus(v)
		return nil
	case comment.FieldReplyUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyUserID(v)
		return nil
	case comment.FieldReplyContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyContent(v)
		return nil
	case comment.FieldReplyTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyTime(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.addorder_id != nil {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.addorder_item_id != nil {
		fields = append(fields, comment.FieldOrderItemID)
	}
	if m.addspu_id != nil {
		fields = append(fields, comment.FieldSpuID)
	}
	if m.addscores != nil {
		fields = append(fields, comment.FieldScores)
	}
	if m.adddescription_scores != nil {
		fields = append(fields, comment.FieldDescriptionScores)
	}
	if m.addbenefit_scores != nil {
		fields = append(fields, comment.FieldBenefitScores)
	}
	if m.addreply_user_id != nil {
		fields = append(fields, comment.FieldReplyUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldUserID:
		return m.AddedUserID()
	case comment.FieldOrderID:
		return m.AddedOrderID()
	case comment.FieldOrderItemID:
		return m.AddedOrderItemID()
	case comment.FieldSpuID:
		return m.AddedSpuID()
	case comment.FieldScores:
		return m.AddedScores()
	case comment.FieldDescriptionScores:
		return m.AddedDescriptionScores()
	case comment.FieldBenefitScores:
		return m.AddedBenefitScores()
	case comment.FieldReplyUserID:
		return m.AddedReplyUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case comment.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case comment.FieldOrderItemID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemID(v)
		return nil
	case comment.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case comment.FieldScores:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScores(v)
		return nil
	case comment.FieldDescriptionScores:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDescriptionScores(v)
		return nil
	case comment.FieldBenefitScores:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBenefitScores(v)
		return nil
	case comment.FieldReplyUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldDeletedAt) {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.FieldCleared(comment.FieldUserID) {
		fields = append(fields, comment.FieldUserID)
	}
	if m.FieldCleared(comment.FieldUserNickname) {
		fields = append(fields, comment.FieldUserNickname)
	}
	if m.FieldCleared(comment.FieldUserAvatar) {
		fields = append(fields, comment.FieldUserAvatar)
	}
	if m.FieldCleared(comment.FieldAnonymous) {
		fields = append(fields, comment.FieldAnonymous)
	}
	if m.FieldCleared(comment.FieldOrderID) {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.FieldCleared(comment.FieldOrderItemID) {
		fields = append(fields, comment.FieldOrderItemID)
	}
	if m.FieldCleared(comment.FieldSpuID) {
		fields = append(fields, comment.FieldSpuID)
	}
	if m.FieldCleared(comment.FieldSpuName) {
		fields = append(fields, comment.FieldSpuName)
	}
	if m.FieldCleared(comment.FieldSkuID) {
		fields = append(fields, comment.FieldSkuID)
	}
	if m.FieldCleared(comment.FieldSkuProperties) {
		fields = append(fields, comment.FieldSkuProperties)
	}
	if m.FieldCleared(comment.FieldVisible) {
		fields = append(fields, comment.FieldVisible)
	}
	if m.FieldCleared(comment.FieldScores) {
		fields = append(fields, comment.FieldScores)
	}
	if m.FieldCleared(comment.FieldDescriptionScores) {
		fields = append(fields, comment.FieldDescriptionScores)
	}
	if m.FieldCleared(comment.FieldBenefitScores) {
		fields = append(fields, comment.FieldBenefitScores)
	}
	if m.FieldCleared(comment.FieldContent) {
		fields = append(fields, comment.FieldContent)
	}
	if m.FieldCleared(comment.FieldPicUrls) {
		fields = append(fields, comment.FieldPicUrls)
	}
	if m.FieldCleared(comment.FieldReplyStatus) {
		fields = append(fields, comment.FieldReplyStatus)
	}
	if m.FieldCleared(comment.FieldReplyUserID) {
		fields = append(fields, comment.FieldReplyUserID)
	}
	if m.FieldCleared(comment.FieldReplyContent) {
		fields = append(fields, comment.FieldReplyContent)
	}
	if m.FieldCleared(comment.FieldReplyTime) {
		fields = append(fields, comment.FieldReplyTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case comment.FieldUserID:
		m.ClearUserID()
		return nil
	case comment.FieldUserNickname:
		m.ClearUserNickname()
		return nil
	case comment.FieldUserAvatar:
		m.ClearUserAvatar()
		return nil
	case comment.FieldAnonymous:
		m.ClearAnonymous()
		return nil
	case comment.FieldOrderID:
		m.ClearOrderID()
		return nil
	case comment.FieldOrderItemID:
		m.ClearOrderItemID()
		return nil
	case comment.FieldSpuID:
		m.ClearSpuID()
		return nil
	case comment.FieldSpuName:
		m.ClearSpuName()
		return nil
	case comment.FieldSkuID:
		m.ClearSkuID()
		return nil
	case comment.FieldSkuProperties:
		m.ClearSkuProperties()
		return nil
	case comment.FieldVisible:
		m.ClearVisible()
		return nil
	case comment.FieldScores:
		m.ClearScores()
		return nil
	case comment.FieldDescriptionScores:
		m.ClearDescriptionScores()
		return nil
	case comment.FieldBenefitScores:
		m.ClearBenefitScores()
		return nil
	case comment.FieldContent:
		m.ClearContent()
		return nil
	case comment.FieldPicUrls:
		m.ClearPicUrls()
		return nil
	case comment.FieldReplyStatus:
		m.ClearReplyStatus()
		return nil
	case comment.FieldReplyUserID:
		m.ClearReplyUserID()
		return nil
	case comment.FieldReplyContent:
		m.ClearReplyContent()
		return nil
	case comment.FieldReplyTime:
		m.ClearReplyTime()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldUserNickname:
		m.ResetUserNickname()
		return nil
	case comment.FieldUserAvatar:
		m.ResetUserAvatar()
		return nil
	case comment.FieldAnonymous:
		m.ResetAnonymous()
		return nil
	case comment.FieldOrderID:
		m.ResetOrderID()
		return nil
	case comment.FieldOrderItemID:
		m.ResetOrderItemID()
		return nil
	case comment.FieldSpuID:
		m.ResetSpuID()
		return nil
	case comment.FieldSpuName:
		m.ResetSpuName()
		return nil
	case comment.FieldSkuID:
		m.ResetSkuID()
		return nil
	case comment.FieldSkuPicURL:
		m.ResetSkuPicURL()
		return nil
	case comment.FieldSkuProperties:
		m.ResetSkuProperties()
		return nil
	case comment.FieldVisible:
		m.ResetVisible()
		return nil
	case comment.FieldScores:
		m.ResetScores()
		return nil
	case comment.FieldDescriptionScores:
		m.ResetDescriptionScores()
		return nil
	case comment.FieldBenefitScores:
		m.ResetBenefitScores()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldPicUrls:
		m.ResetPicUrls()
		return nil
	case comment.FieldReplyStatus:
		m.ResetReplyStatus()
		return nil
	case comment.FieldReplyUserID:
		m.ResetReplyUserID()
		return nil
	case comment.FieldReplyContent:
		m.ResetReplyContent()
		return nil
	case comment.FieldReplyTime:
		m.ResetReplyTime()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.skus != nil {
		edges = append(edges, comment.EdgeSkus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeSkus:
		if id := m.skus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedskus {
		edges = append(edges, comment.EdgeSkus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeSkus:
		return m.clearedskus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeSkus:
		m.ClearSkus()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeSkus:
		m.ResetSkus()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint64
	created_at             *time.Time
	updated_at             *time.Time
	status                 *uint8
	addstatus              *int8
	deleted_at             *time.Time
	name                   *string
	remark                 *string
	clearedFields          map[string]struct{}
	property_values        map[uint64]struct{}
	removedproperty_values map[uint64]struct{}
	clearedproperty_values bool
	done                   bool
	oldValue               func(context.Context) (*Property, error)
	predicates             []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id uint64) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *PropertyMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PropertyMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PropertyMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PropertyMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *PropertyMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[property.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PropertyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[property.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PropertyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, property.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PropertyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PropertyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PropertyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[property.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PropertyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[property.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PropertyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, property.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PropertyMutation) ClearName() {
	m.name = nil
	m.clearedFields[property.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PropertyMutation) NameCleared() bool {
	_, ok := m.clearedFields[property.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PropertyMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, property.FieldName)
}

// SetRemark sets the "remark" field.
func (m *PropertyMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PropertyMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PropertyMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[property.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PropertyMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[property.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PropertyMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, property.FieldRemark)
}

// AddPropertyValueIDs adds the "property_values" edge to the PropertyValue entity by ids.
func (m *PropertyMutation) AddPropertyValueIDs(ids ...uint64) {
	if m.property_values == nil {
		m.property_values = make(map[uint64]struct{})
	}
	for i := range ids {
		m.property_values[ids[i]] = struct{}{}
	}
}

// ClearPropertyValues clears the "property_values" edge to the PropertyValue entity.
func (m *PropertyMutation) ClearPropertyValues() {
	m.clearedproperty_values = true
}

// PropertyValuesCleared reports if the "property_values" edge to the PropertyValue entity was cleared.
func (m *PropertyMutation) PropertyValuesCleared() bool {
	return m.clearedproperty_values
}

// RemovePropertyValueIDs removes the "property_values" edge to the PropertyValue entity by IDs.
func (m *PropertyMutation) RemovePropertyValueIDs(ids ...uint64) {
	if m.removedproperty_values == nil {
		m.removedproperty_values = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.property_values, ids[i])
		m.removedproperty_values[ids[i]] = struct{}{}
	}
}

// RemovedPropertyValues returns the removed IDs of the "property_values" edge to the PropertyValue entity.
func (m *PropertyMutation) RemovedPropertyValuesIDs() (ids []uint64) {
	for id := range m.removedproperty_values {
		ids = append(ids, id)
	}
	return
}

// PropertyValuesIDs returns the "property_values" edge IDs in the mutation.
func (m *PropertyMutation) PropertyValuesIDs() (ids []uint64) {
	for id := range m.property_values {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyValues resets all changes to the "property_values" edge.
func (m *PropertyMutation) ResetPropertyValues() {
	m.property_values = nil
	m.clearedproperty_values = false
	m.removedproperty_values = nil
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, property.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, property.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, property.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, property.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, property.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, property.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldCreatedAt:
		return m.CreatedAt()
	case property.FieldUpdatedAt:
		return m.UpdatedAt()
	case property.FieldStatus:
		return m.Status()
	case property.FieldDeletedAt:
		return m.DeletedAt()
	case property.FieldName:
		return m.Name()
	case property.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case property.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case property.FieldStatus:
		return m.OldStatus(ctx)
	case property.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case property.FieldName:
		return m.OldName(ctx)
	case property.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case property.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case property.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case property.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case property.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case property.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, property.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case property.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case property.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(property.FieldStatus) {
		fields = append(fields, property.FieldStatus)
	}
	if m.FieldCleared(property.FieldDeletedAt) {
		fields = append(fields, property.FieldDeletedAt)
	}
	if m.FieldCleared(property.FieldName) {
		fields = append(fields, property.FieldName)
	}
	if m.FieldCleared(property.FieldRemark) {
		fields = append(fields, property.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	switch name {
	case property.FieldStatus:
		m.ClearStatus()
		return nil
	case property.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case property.FieldName:
		m.ClearName()
		return nil
	case property.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case property.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case property.FieldStatus:
		m.ResetStatus()
		return nil
	case property.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case property.FieldName:
		m.ResetName()
		return nil
	case property.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.property_values != nil {
		edges = append(edges, property.EdgePropertyValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgePropertyValues:
		ids := make([]ent.Value, 0, len(m.property_values))
		for id := range m.property_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproperty_values != nil {
		edges = append(edges, property.EdgePropertyValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case property.EdgePropertyValues:
		ids := make([]ent.Value, 0, len(m.removedproperty_values))
		for id := range m.removedproperty_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproperty_values {
		edges = append(edges, property.EdgePropertyValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgePropertyValues:
		return m.clearedproperty_values
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgePropertyValues:
		m.ResetPropertyValues()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// PropertyValueMutation represents an operation that mutates the PropertyValue nodes in the graph.
type PropertyValueMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name             *string
	remark           *string
	clearedFields    map[string]struct{}
	propertys        *uint64
	clearedpropertys bool
	done             bool
	oldValue         func(context.Context) (*PropertyValue, error)
	predicates       []predicate.PropertyValue
}

var _ ent.Mutation = (*PropertyValueMutation)(nil)

// propertyvalueOption allows management of the mutation configuration using functional options.
type propertyvalueOption func(*PropertyValueMutation)

// newPropertyValueMutation creates new mutation for the PropertyValue entity.
func newPropertyValueMutation(c config, op Op, opts ...propertyvalueOption) *PropertyValueMutation {
	m := &PropertyValueMutation{
		config:        c,
		op:            op,
		typ:           TypePropertyValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyValueID sets the ID field of the mutation.
func withPropertyValueID(id uint64) propertyvalueOption {
	return func(m *PropertyValueMutation) {
		var (
			err   error
			once  sync.Once
			value *PropertyValue
		)
		m.oldValue = func(ctx context.Context) (*PropertyValue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PropertyValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPropertyValue sets the old PropertyValue of the mutation.
func withPropertyValue(node *PropertyValue) propertyvalueOption {
	return func(m *PropertyValueMutation) {
		m.oldValue = func(context.Context) (*PropertyValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PropertyValue entities.
func (m *PropertyValueMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyValueMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyValueMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PropertyValue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PropertyValueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PropertyValueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PropertyValue entity.
// If the PropertyValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyValueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PropertyValueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PropertyValueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PropertyValueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PropertyValue entity.
// If the PropertyValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyValueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PropertyValueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PropertyValueMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PropertyValueMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PropertyValue entity.
// If the PropertyValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyValueMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PropertyValueMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[propertyvalue.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PropertyValueMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[propertyvalue.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PropertyValueMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, propertyvalue.FieldDeletedAt)
}

// SetPropertyID sets the "property_id" field.
func (m *PropertyValueMutation) SetPropertyID(u uint64) {
	m.propertys = &u
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *PropertyValueMutation) PropertyID() (r uint64, exists bool) {
	v := m.propertys
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the PropertyValue entity.
// If the PropertyValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyValueMutation) OldPropertyID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// ClearPropertyID clears the value of the "property_id" field.
func (m *PropertyValueMutation) ClearPropertyID() {
	m.propertys = nil
	m.clearedFields[propertyvalue.FieldPropertyID] = struct{}{}
}

// PropertyIDCleared returns if the "property_id" field was cleared in this mutation.
func (m *PropertyValueMutation) PropertyIDCleared() bool {
	_, ok := m.clearedFields[propertyvalue.FieldPropertyID]
	return ok
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *PropertyValueMutation) ResetPropertyID() {
	m.propertys = nil
	delete(m.clearedFields, propertyvalue.FieldPropertyID)
}

// SetName sets the "name" field.
func (m *PropertyValueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertyValueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PropertyValue entity.
// If the PropertyValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyValueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PropertyValueMutation) ClearName() {
	m.name = nil
	m.clearedFields[propertyvalue.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PropertyValueMutation) NameCleared() bool {
	_, ok := m.clearedFields[propertyvalue.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PropertyValueMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, propertyvalue.FieldName)
}

// SetRemark sets the "remark" field.
func (m *PropertyValueMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PropertyValueMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PropertyValue entity.
// If the PropertyValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyValueMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PropertyValueMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[propertyvalue.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PropertyValueMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[propertyvalue.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PropertyValueMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, propertyvalue.FieldRemark)
}

// SetPropertysID sets the "propertys" edge to the Property entity by id.
func (m *PropertyValueMutation) SetPropertysID(id uint64) {
	m.propertys = &id
}

// ClearPropertys clears the "propertys" edge to the Property entity.
func (m *PropertyValueMutation) ClearPropertys() {
	m.clearedpropertys = true
	m.clearedFields[propertyvalue.FieldPropertyID] = struct{}{}
}

// PropertysCleared reports if the "propertys" edge to the Property entity was cleared.
func (m *PropertyValueMutation) PropertysCleared() bool {
	return m.PropertyIDCleared() || m.clearedpropertys
}

// PropertysID returns the "propertys" edge ID in the mutation.
func (m *PropertyValueMutation) PropertysID() (id uint64, exists bool) {
	if m.propertys != nil {
		return *m.propertys, true
	}
	return
}

// PropertysIDs returns the "propertys" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertysID instead. It exists only for internal usage by the builders.
func (m *PropertyValueMutation) PropertysIDs() (ids []uint64) {
	if id := m.propertys; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPropertys resets all changes to the "propertys" edge.
func (m *PropertyValueMutation) ResetPropertys() {
	m.propertys = nil
	m.clearedpropertys = false
}

// Where appends a list predicates to the PropertyValueMutation builder.
func (m *PropertyValueMutation) Where(ps ...predicate.PropertyValue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyValueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyValueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PropertyValue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyValueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyValueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PropertyValue).
func (m *PropertyValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyValueMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, propertyvalue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, propertyvalue.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, propertyvalue.FieldDeletedAt)
	}
	if m.propertys != nil {
		fields = append(fields, propertyvalue.FieldPropertyID)
	}
	if m.name != nil {
		fields = append(fields, propertyvalue.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, propertyvalue.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case propertyvalue.FieldCreatedAt:
		return m.CreatedAt()
	case propertyvalue.FieldUpdatedAt:
		return m.UpdatedAt()
	case propertyvalue.FieldDeletedAt:
		return m.DeletedAt()
	case propertyvalue.FieldPropertyID:
		return m.PropertyID()
	case propertyvalue.FieldName:
		return m.Name()
	case propertyvalue.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case propertyvalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case propertyvalue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case propertyvalue.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case propertyvalue.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case propertyvalue.FieldName:
		return m.OldName(ctx)
	case propertyvalue.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown PropertyValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case propertyvalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case propertyvalue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case propertyvalue.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case propertyvalue.FieldPropertyID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case propertyvalue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case propertyvalue.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyValueMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PropertyValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyValueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(propertyvalue.FieldDeletedAt) {
		fields = append(fields, propertyvalue.FieldDeletedAt)
	}
	if m.FieldCleared(propertyvalue.FieldPropertyID) {
		fields = append(fields, propertyvalue.FieldPropertyID)
	}
	if m.FieldCleared(propertyvalue.FieldName) {
		fields = append(fields, propertyvalue.FieldName)
	}
	if m.FieldCleared(propertyvalue.FieldRemark) {
		fields = append(fields, propertyvalue.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyValueMutation) ClearField(name string) error {
	switch name {
	case propertyvalue.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case propertyvalue.FieldPropertyID:
		m.ClearPropertyID()
		return nil
	case propertyvalue.FieldName:
		m.ClearName()
		return nil
	case propertyvalue.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown PropertyValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyValueMutation) ResetField(name string) error {
	switch name {
	case propertyvalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case propertyvalue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case propertyvalue.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case propertyvalue.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case propertyvalue.FieldName:
		m.ResetName()
		return nil
	case propertyvalue.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown PropertyValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.propertys != nil {
		edges = append(edges, propertyvalue.EdgePropertys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case propertyvalue.EdgePropertys:
		if id := m.propertys; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpropertys {
		edges = append(edges, propertyvalue.EdgePropertys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyValueMutation) EdgeCleared(name string) bool {
	switch name {
	case propertyvalue.EdgePropertys:
		return m.clearedpropertys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyValueMutation) ClearEdge(name string) error {
	switch name {
	case propertyvalue.EdgePropertys:
		m.ClearPropertys()
		return nil
	}
	return fmt.Errorf("unknown PropertyValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyValueMutation) ResetEdge(name string) error {
	switch name {
	case propertyvalue.EdgePropertys:
		m.ResetPropertys()
		return nil
	}
	return fmt.Errorf("unknown PropertyValue edge %s", name)
}

// SkuMutation represents an operation that mutates the Sku nodes in the graph.
type SkuMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint64
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	properties                *[]entType.SkuProperty
	appendproperties          []entType.SkuProperty
	price                     *int32
	addprice                  *int32
	market_price              *int32
	addmarket_price           *int32
	cost_price                *int32
	addcost_price             *int32
	bar_code                  *string
	pic_url                   *string
	stock                     *int32
	addstock                  *int32
	weight                    *float64
	addweight                 *float64
	volume                    *float64
	addvolume                 *float64
	first_brokerage_price     *int32
	addfirst_brokerage_price  *int32
	second_brokerage_price    *float64
	addsecond_brokerage_price *float64
	sales_count               *int32
	addsales_count            *int32
	clearedFields             map[string]struct{}
	spus                      *uint64
	clearedspus               bool
	comments                  map[uint64]struct{}
	removedcomments           map[uint64]struct{}
	clearedcomments           bool
	done                      bool
	oldValue                  func(context.Context) (*Sku, error)
	predicates                []predicate.Sku
}

var _ ent.Mutation = (*SkuMutation)(nil)

// skuOption allows management of the mutation configuration using functional options.
type skuOption func(*SkuMutation)

// newSkuMutation creates new mutation for the Sku entity.
func newSkuMutation(c config, op Op, opts ...skuOption) *SkuMutation {
	m := &SkuMutation{
		config:        c,
		op:            op,
		typ:           TypeSku,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkuID sets the ID field of the mutation.
func withSkuID(id uint64) skuOption {
	return func(m *SkuMutation) {
		var (
			err   error
			once  sync.Once
			value *Sku
		)
		m.oldValue = func(ctx context.Context) (*Sku, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sku.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSku sets the old Sku of the mutation.
func withSku(node *Sku) skuOption {
	return func(m *SkuMutation) {
		m.oldValue = func(context.Context) (*Sku, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sku entities.
func (m *SkuMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkuMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkuMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sku.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SkuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SkuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SkuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SkuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SkuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SkuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SkuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SkuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SkuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sku.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SkuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sku.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SkuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sku.FieldDeletedAt)
}

// SetSpuID sets the "spu_id" field.
func (m *SkuMutation) SetSpuID(u uint64) {
	m.spus = &u
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SkuMutation) SpuID() (r uint64, exists bool) {
	v := m.spus
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldSpuID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SkuMutation) ClearSpuID() {
	m.spus = nil
	m.clearedFields[sku.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SkuMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[sku.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SkuMutation) ResetSpuID() {
	m.spus = nil
	delete(m.clearedFields, sku.FieldSpuID)
}

// SetProperties sets the "properties" field.
func (m *SkuMutation) SetProperties(etp []entType.SkuProperty) {
	m.properties = &etp
	m.appendproperties = nil
}

// Properties returns the value of the "properties" field in the mutation.
func (m *SkuMutation) Properties() (r []entType.SkuProperty, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldProperties(ctx context.Context) (v []entType.SkuProperty, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// AppendProperties adds etp to the "properties" field.
func (m *SkuMutation) AppendProperties(etp []entType.SkuProperty) {
	m.appendproperties = append(m.appendproperties, etp...)
}

// AppendedProperties returns the list of values that were appended to the "properties" field in this mutation.
func (m *SkuMutation) AppendedProperties() ([]entType.SkuProperty, bool) {
	if len(m.appendproperties) == 0 {
		return nil, false
	}
	return m.appendproperties, true
}

// ClearProperties clears the value of the "properties" field.
func (m *SkuMutation) ClearProperties() {
	m.properties = nil
	m.appendproperties = nil
	m.clearedFields[sku.FieldProperties] = struct{}{}
}

// PropertiesCleared returns if the "properties" field was cleared in this mutation.
func (m *SkuMutation) PropertiesCleared() bool {
	_, ok := m.clearedFields[sku.FieldProperties]
	return ok
}

// ResetProperties resets all changes to the "properties" field.
func (m *SkuMutation) ResetProperties() {
	m.properties = nil
	m.appendproperties = nil
	delete(m.clearedFields, sku.FieldProperties)
}

// SetPrice sets the "price" field.
func (m *SkuMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SkuMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *SkuMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SkuMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *SkuMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetMarketPrice sets the "market_price" field.
func (m *SkuMutation) SetMarketPrice(i int32) {
	m.market_price = &i
	m.addmarket_price = nil
}

// MarketPrice returns the value of the "market_price" field in the mutation.
func (m *SkuMutation) MarketPrice() (r int32, exists bool) {
	v := m.market_price
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketPrice returns the old "market_price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldMarketPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketPrice: %w", err)
	}
	return oldValue.MarketPrice, nil
}

// AddMarketPrice adds i to the "market_price" field.
func (m *SkuMutation) AddMarketPrice(i int32) {
	if m.addmarket_price != nil {
		*m.addmarket_price += i
	} else {
		m.addmarket_price = &i
	}
}

// AddedMarketPrice returns the value that was added to the "market_price" field in this mutation.
func (m *SkuMutation) AddedMarketPrice() (r int32, exists bool) {
	v := m.addmarket_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearMarketPrice clears the value of the "market_price" field.
func (m *SkuMutation) ClearMarketPrice() {
	m.market_price = nil
	m.addmarket_price = nil
	m.clearedFields[sku.FieldMarketPrice] = struct{}{}
}

// MarketPriceCleared returns if the "market_price" field was cleared in this mutation.
func (m *SkuMutation) MarketPriceCleared() bool {
	_, ok := m.clearedFields[sku.FieldMarketPrice]
	return ok
}

// ResetMarketPrice resets all changes to the "market_price" field.
func (m *SkuMutation) ResetMarketPrice() {
	m.market_price = nil
	m.addmarket_price = nil
	delete(m.clearedFields, sku.FieldMarketPrice)
}

// SetCostPrice sets the "cost_price" field.
func (m *SkuMutation) SetCostPrice(i int32) {
	m.cost_price = &i
	m.addcost_price = nil
}

// CostPrice returns the value of the "cost_price" field in the mutation.
func (m *SkuMutation) CostPrice() (r int32, exists bool) {
	v := m.cost_price
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPrice returns the old "cost_price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCostPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPrice: %w", err)
	}
	return oldValue.CostPrice, nil
}

// AddCostPrice adds i to the "cost_price" field.
func (m *SkuMutation) AddCostPrice(i int32) {
	if m.addcost_price != nil {
		*m.addcost_price += i
	} else {
		m.addcost_price = &i
	}
}

// AddedCostPrice returns the value that was added to the "cost_price" field in this mutation.
func (m *SkuMutation) AddedCostPrice() (r int32, exists bool) {
	v := m.addcost_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetCostPrice resets all changes to the "cost_price" field.
func (m *SkuMutation) ResetCostPrice() {
	m.cost_price = nil
	m.addcost_price = nil
}

// SetBarCode sets the "bar_code" field.
func (m *SkuMutation) SetBarCode(s string) {
	m.bar_code = &s
}

// BarCode returns the value of the "bar_code" field in the mutation.
func (m *SkuMutation) BarCode() (r string, exists bool) {
	v := m.bar_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBarCode returns the old "bar_code" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldBarCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarCode: %w", err)
	}
	return oldValue.BarCode, nil
}

// ClearBarCode clears the value of the "bar_code" field.
func (m *SkuMutation) ClearBarCode() {
	m.bar_code = nil
	m.clearedFields[sku.FieldBarCode] = struct{}{}
}

// BarCodeCleared returns if the "bar_code" field was cleared in this mutation.
func (m *SkuMutation) BarCodeCleared() bool {
	_, ok := m.clearedFields[sku.FieldBarCode]
	return ok
}

// ResetBarCode resets all changes to the "bar_code" field.
func (m *SkuMutation) ResetBarCode() {
	m.bar_code = nil
	delete(m.clearedFields, sku.FieldBarCode)
}

// SetPicURL sets the "pic_url" field.
func (m *SkuMutation) SetPicURL(s string) {
	m.pic_url = &s
}

// PicURL returns the value of the "pic_url" field in the mutation.
func (m *SkuMutation) PicURL() (r string, exists bool) {
	v := m.pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPicURL returns the old "pic_url" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicURL: %w", err)
	}
	return oldValue.PicURL, nil
}

// ResetPicURL resets all changes to the "pic_url" field.
func (m *SkuMutation) ResetPicURL() {
	m.pic_url = nil
}

// SetStock sets the "stock" field.
func (m *SkuMutation) SetStock(i int32) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *SkuMutation) Stock() (r int32, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldStock(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *SkuMutation) AddStock(i int32) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *SkuMutation) AddedStock() (r int32, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ClearStock clears the value of the "stock" field.
func (m *SkuMutation) ClearStock() {
	m.stock = nil
	m.addstock = nil
	m.clearedFields[sku.FieldStock] = struct{}{}
}

// StockCleared returns if the "stock" field was cleared in this mutation.
func (m *SkuMutation) StockCleared() bool {
	_, ok := m.clearedFields[sku.FieldStock]
	return ok
}

// ResetStock resets all changes to the "stock" field.
func (m *SkuMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
	delete(m.clearedFields, sku.FieldStock)
}

// SetWeight sets the "weight" field.
func (m *SkuMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *SkuMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *SkuMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *SkuMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *SkuMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[sku.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *SkuMutation) WeightCleared() bool {
	_, ok := m.clearedFields[sku.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *SkuMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, sku.FieldWeight)
}

// SetVolume sets the "volume" field.
func (m *SkuMutation) SetVolume(f float64) {
	m.volume = &f
	m.addvolume = nil
}

// Volume returns the value of the "volume" field in the mutation.
func (m *SkuMutation) Volume() (r float64, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldVolume(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// AddVolume adds f to the "volume" field.
func (m *SkuMutation) AddVolume(f float64) {
	if m.addvolume != nil {
		*m.addvolume += f
	} else {
		m.addvolume = &f
	}
}

// AddedVolume returns the value that was added to the "volume" field in this mutation.
func (m *SkuMutation) AddedVolume() (r float64, exists bool) {
	v := m.addvolume
	if v == nil {
		return
	}
	return *v, true
}

// ClearVolume clears the value of the "volume" field.
func (m *SkuMutation) ClearVolume() {
	m.volume = nil
	m.addvolume = nil
	m.clearedFields[sku.FieldVolume] = struct{}{}
}

// VolumeCleared returns if the "volume" field was cleared in this mutation.
func (m *SkuMutation) VolumeCleared() bool {
	_, ok := m.clearedFields[sku.FieldVolume]
	return ok
}

// ResetVolume resets all changes to the "volume" field.
func (m *SkuMutation) ResetVolume() {
	m.volume = nil
	m.addvolume = nil
	delete(m.clearedFields, sku.FieldVolume)
}

// SetFirstBrokeragePrice sets the "first_brokerage_price" field.
func (m *SkuMutation) SetFirstBrokeragePrice(i int32) {
	m.first_brokerage_price = &i
	m.addfirst_brokerage_price = nil
}

// FirstBrokeragePrice returns the value of the "first_brokerage_price" field in the mutation.
func (m *SkuMutation) FirstBrokeragePrice() (r int32, exists bool) {
	v := m.first_brokerage_price
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstBrokeragePrice returns the old "first_brokerage_price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldFirstBrokeragePrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstBrokeragePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstBrokeragePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstBrokeragePrice: %w", err)
	}
	return oldValue.FirstBrokeragePrice, nil
}

// AddFirstBrokeragePrice adds i to the "first_brokerage_price" field.
func (m *SkuMutation) AddFirstBrokeragePrice(i int32) {
	if m.addfirst_brokerage_price != nil {
		*m.addfirst_brokerage_price += i
	} else {
		m.addfirst_brokerage_price = &i
	}
}

// AddedFirstBrokeragePrice returns the value that was added to the "first_brokerage_price" field in this mutation.
func (m *SkuMutation) AddedFirstBrokeragePrice() (r int32, exists bool) {
	v := m.addfirst_brokerage_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstBrokeragePrice clears the value of the "first_brokerage_price" field.
func (m *SkuMutation) ClearFirstBrokeragePrice() {
	m.first_brokerage_price = nil
	m.addfirst_brokerage_price = nil
	m.clearedFields[sku.FieldFirstBrokeragePrice] = struct{}{}
}

// FirstBrokeragePriceCleared returns if the "first_brokerage_price" field was cleared in this mutation.
func (m *SkuMutation) FirstBrokeragePriceCleared() bool {
	_, ok := m.clearedFields[sku.FieldFirstBrokeragePrice]
	return ok
}

// ResetFirstBrokeragePrice resets all changes to the "first_brokerage_price" field.
func (m *SkuMutation) ResetFirstBrokeragePrice() {
	m.first_brokerage_price = nil
	m.addfirst_brokerage_price = nil
	delete(m.clearedFields, sku.FieldFirstBrokeragePrice)
}

// SetSecondBrokeragePrice sets the "second_brokerage_price" field.
func (m *SkuMutation) SetSecondBrokeragePrice(f float64) {
	m.second_brokerage_price = &f
	m.addsecond_brokerage_price = nil
}

// SecondBrokeragePrice returns the value of the "second_brokerage_price" field in the mutation.
func (m *SkuMutation) SecondBrokeragePrice() (r float64, exists bool) {
	v := m.second_brokerage_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondBrokeragePrice returns the old "second_brokerage_price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldSecondBrokeragePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondBrokeragePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondBrokeragePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondBrokeragePrice: %w", err)
	}
	return oldValue.SecondBrokeragePrice, nil
}

// AddSecondBrokeragePrice adds f to the "second_brokerage_price" field.
func (m *SkuMutation) AddSecondBrokeragePrice(f float64) {
	if m.addsecond_brokerage_price != nil {
		*m.addsecond_brokerage_price += f
	} else {
		m.addsecond_brokerage_price = &f
	}
}

// AddedSecondBrokeragePrice returns the value that was added to the "second_brokerage_price" field in this mutation.
func (m *SkuMutation) AddedSecondBrokeragePrice() (r float64, exists bool) {
	v := m.addsecond_brokerage_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearSecondBrokeragePrice clears the value of the "second_brokerage_price" field.
func (m *SkuMutation) ClearSecondBrokeragePrice() {
	m.second_brokerage_price = nil
	m.addsecond_brokerage_price = nil
	m.clearedFields[sku.FieldSecondBrokeragePrice] = struct{}{}
}

// SecondBrokeragePriceCleared returns if the "second_brokerage_price" field was cleared in this mutation.
func (m *SkuMutation) SecondBrokeragePriceCleared() bool {
	_, ok := m.clearedFields[sku.FieldSecondBrokeragePrice]
	return ok
}

// ResetSecondBrokeragePrice resets all changes to the "second_brokerage_price" field.
func (m *SkuMutation) ResetSecondBrokeragePrice() {
	m.second_brokerage_price = nil
	m.addsecond_brokerage_price = nil
	delete(m.clearedFields, sku.FieldSecondBrokeragePrice)
}

// SetSalesCount sets the "sales_count" field.
func (m *SkuMutation) SetSalesCount(i int32) {
	m.sales_count = &i
	m.addsales_count = nil
}

// SalesCount returns the value of the "sales_count" field in the mutation.
func (m *SkuMutation) SalesCount() (r int32, exists bool) {
	v := m.sales_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesCount returns the old "sales_count" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldSalesCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesCount: %w", err)
	}
	return oldValue.SalesCount, nil
}

// AddSalesCount adds i to the "sales_count" field.
func (m *SkuMutation) AddSalesCount(i int32) {
	if m.addsales_count != nil {
		*m.addsales_count += i
	} else {
		m.addsales_count = &i
	}
}

// AddedSalesCount returns the value that was added to the "sales_count" field in this mutation.
func (m *SkuMutation) AddedSalesCount() (r int32, exists bool) {
	v := m.addsales_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesCount clears the value of the "sales_count" field.
func (m *SkuMutation) ClearSalesCount() {
	m.sales_count = nil
	m.addsales_count = nil
	m.clearedFields[sku.FieldSalesCount] = struct{}{}
}

// SalesCountCleared returns if the "sales_count" field was cleared in this mutation.
func (m *SkuMutation) SalesCountCleared() bool {
	_, ok := m.clearedFields[sku.FieldSalesCount]
	return ok
}

// ResetSalesCount resets all changes to the "sales_count" field.
func (m *SkuMutation) ResetSalesCount() {
	m.sales_count = nil
	m.addsales_count = nil
	delete(m.clearedFields, sku.FieldSalesCount)
}

// SetSpusID sets the "spus" edge to the Spu entity by id.
func (m *SkuMutation) SetSpusID(id uint64) {
	m.spus = &id
}

// ClearSpus clears the "spus" edge to the Spu entity.
func (m *SkuMutation) ClearSpus() {
	m.clearedspus = true
	m.clearedFields[sku.FieldSpuID] = struct{}{}
}

// SpusCleared reports if the "spus" edge to the Spu entity was cleared.
func (m *SkuMutation) SpusCleared() bool {
	return m.SpuIDCleared() || m.clearedspus
}

// SpusID returns the "spus" edge ID in the mutation.
func (m *SkuMutation) SpusID() (id uint64, exists bool) {
	if m.spus != nil {
		return *m.spus, true
	}
	return
}

// SpusIDs returns the "spus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpusID instead. It exists only for internal usage by the builders.
func (m *SkuMutation) SpusIDs() (ids []uint64) {
	if id := m.spus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpus resets all changes to the "spus" edge.
func (m *SkuMutation) ResetSpus() {
	m.spus = nil
	m.clearedspus = false
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *SkuMutation) AddCommentIDs(ids ...uint64) {
	if m.comments == nil {
		m.comments = make(map[uint64]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *SkuMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *SkuMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *SkuMutation) RemoveCommentIDs(ids ...uint64) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *SkuMutation) RemovedCommentsIDs() (ids []uint64) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *SkuMutation) CommentsIDs() (ids []uint64) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *SkuMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the SkuMutation builder.
func (m *SkuMutation) Where(ps ...predicate.Sku) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sku, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sku).
func (m *SkuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkuMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, sku.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sku.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sku.FieldDeletedAt)
	}
	if m.spus != nil {
		fields = append(fields, sku.FieldSpuID)
	}
	if m.properties != nil {
		fields = append(fields, sku.FieldProperties)
	}
	if m.price != nil {
		fields = append(fields, sku.FieldPrice)
	}
	if m.market_price != nil {
		fields = append(fields, sku.FieldMarketPrice)
	}
	if m.cost_price != nil {
		fields = append(fields, sku.FieldCostPrice)
	}
	if m.bar_code != nil {
		fields = append(fields, sku.FieldBarCode)
	}
	if m.pic_url != nil {
		fields = append(fields, sku.FieldPicURL)
	}
	if m.stock != nil {
		fields = append(fields, sku.FieldStock)
	}
	if m.weight != nil {
		fields = append(fields, sku.FieldWeight)
	}
	if m.volume != nil {
		fields = append(fields, sku.FieldVolume)
	}
	if m.first_brokerage_price != nil {
		fields = append(fields, sku.FieldFirstBrokeragePrice)
	}
	if m.second_brokerage_price != nil {
		fields = append(fields, sku.FieldSecondBrokeragePrice)
	}
	if m.sales_count != nil {
		fields = append(fields, sku.FieldSalesCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sku.FieldCreatedAt:
		return m.CreatedAt()
	case sku.FieldUpdatedAt:
		return m.UpdatedAt()
	case sku.FieldDeletedAt:
		return m.DeletedAt()
	case sku.FieldSpuID:
		return m.SpuID()
	case sku.FieldProperties:
		return m.Properties()
	case sku.FieldPrice:
		return m.Price()
	case sku.FieldMarketPrice:
		return m.MarketPrice()
	case sku.FieldCostPrice:
		return m.CostPrice()
	case sku.FieldBarCode:
		return m.BarCode()
	case sku.FieldPicURL:
		return m.PicURL()
	case sku.FieldStock:
		return m.Stock()
	case sku.FieldWeight:
		return m.Weight()
	case sku.FieldVolume:
		return m.Volume()
	case sku.FieldFirstBrokeragePrice:
		return m.FirstBrokeragePrice()
	case sku.FieldSecondBrokeragePrice:
		return m.SecondBrokeragePrice()
	case sku.FieldSalesCount:
		return m.SalesCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sku.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sku.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sku.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sku.FieldSpuID:
		return m.OldSpuID(ctx)
	case sku.FieldProperties:
		return m.OldProperties(ctx)
	case sku.FieldPrice:
		return m.OldPrice(ctx)
	case sku.FieldMarketPrice:
		return m.OldMarketPrice(ctx)
	case sku.FieldCostPrice:
		return m.OldCostPrice(ctx)
	case sku.FieldBarCode:
		return m.OldBarCode(ctx)
	case sku.FieldPicURL:
		return m.OldPicURL(ctx)
	case sku.FieldStock:
		return m.OldStock(ctx)
	case sku.FieldWeight:
		return m.OldWeight(ctx)
	case sku.FieldVolume:
		return m.OldVolume(ctx)
	case sku.FieldFirstBrokeragePrice:
		return m.OldFirstBrokeragePrice(ctx)
	case sku.FieldSecondBrokeragePrice:
		return m.OldSecondBrokeragePrice(ctx)
	case sku.FieldSalesCount:
		return m.OldSalesCount(ctx)
	}
	return nil, fmt.Errorf("unknown Sku field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sku.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sku.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sku.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sku.FieldSpuID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case sku.FieldProperties:
		v, ok := value.([]entType.SkuProperty)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case sku.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case sku.FieldMarketPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketPrice(v)
		return nil
	case sku.FieldCostPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPrice(v)
		return nil
	case sku.FieldBarCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarCode(v)
		return nil
	case sku.FieldPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicURL(v)
		return nil
	case sku.FieldStock:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case sku.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case sku.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case sku.FieldFirstBrokeragePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstBrokeragePrice(v)
		return nil
	case sku.FieldSecondBrokeragePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondBrokeragePrice(v)
		return nil
	case sku.FieldSalesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Sku field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkuMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, sku.FieldPrice)
	}
	if m.addmarket_price != nil {
		fields = append(fields, sku.FieldMarketPrice)
	}
	if m.addcost_price != nil {
		fields = append(fields, sku.FieldCostPrice)
	}
	if m.addstock != nil {
		fields = append(fields, sku.FieldStock)
	}
	if m.addweight != nil {
		fields = append(fields, sku.FieldWeight)
	}
	if m.addvolume != nil {
		fields = append(fields, sku.FieldVolume)
	}
	if m.addfirst_brokerage_price != nil {
		fields = append(fields, sku.FieldFirstBrokeragePrice)
	}
	if m.addsecond_brokerage_price != nil {
		fields = append(fields, sku.FieldSecondBrokeragePrice)
	}
	if m.addsales_count != nil {
		fields = append(fields, sku.FieldSalesCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sku.FieldPrice:
		return m.AddedPrice()
	case sku.FieldMarketPrice:
		return m.AddedMarketPrice()
	case sku.FieldCostPrice:
		return m.AddedCostPrice()
	case sku.FieldStock:
		return m.AddedStock()
	case sku.FieldWeight:
		return m.AddedWeight()
	case sku.FieldVolume:
		return m.AddedVolume()
	case sku.FieldFirstBrokeragePrice:
		return m.AddedFirstBrokeragePrice()
	case sku.FieldSecondBrokeragePrice:
		return m.AddedSecondBrokeragePrice()
	case sku.FieldSalesCount:
		return m.AddedSalesCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sku.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case sku.FieldMarketPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketPrice(v)
		return nil
	case sku.FieldCostPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostPrice(v)
		return nil
	case sku.FieldStock:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case sku.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case sku.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolume(v)
		return nil
	case sku.FieldFirstBrokeragePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstBrokeragePrice(v)
		return nil
	case sku.FieldSecondBrokeragePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecondBrokeragePrice(v)
		return nil
	case sku.FieldSalesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Sku numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sku.FieldDeletedAt) {
		fields = append(fields, sku.FieldDeletedAt)
	}
	if m.FieldCleared(sku.FieldSpuID) {
		fields = append(fields, sku.FieldSpuID)
	}
	if m.FieldCleared(sku.FieldProperties) {
		fields = append(fields, sku.FieldProperties)
	}
	if m.FieldCleared(sku.FieldMarketPrice) {
		fields = append(fields, sku.FieldMarketPrice)
	}
	if m.FieldCleared(sku.FieldBarCode) {
		fields = append(fields, sku.FieldBarCode)
	}
	if m.FieldCleared(sku.FieldStock) {
		fields = append(fields, sku.FieldStock)
	}
	if m.FieldCleared(sku.FieldWeight) {
		fields = append(fields, sku.FieldWeight)
	}
	if m.FieldCleared(sku.FieldVolume) {
		fields = append(fields, sku.FieldVolume)
	}
	if m.FieldCleared(sku.FieldFirstBrokeragePrice) {
		fields = append(fields, sku.FieldFirstBrokeragePrice)
	}
	if m.FieldCleared(sku.FieldSecondBrokeragePrice) {
		fields = append(fields, sku.FieldSecondBrokeragePrice)
	}
	if m.FieldCleared(sku.FieldSalesCount) {
		fields = append(fields, sku.FieldSalesCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkuMutation) ClearField(name string) error {
	switch name {
	case sku.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sku.FieldSpuID:
		m.ClearSpuID()
		return nil
	case sku.FieldProperties:
		m.ClearProperties()
		return nil
	case sku.FieldMarketPrice:
		m.ClearMarketPrice()
		return nil
	case sku.FieldBarCode:
		m.ClearBarCode()
		return nil
	case sku.FieldStock:
		m.ClearStock()
		return nil
	case sku.FieldWeight:
		m.ClearWeight()
		return nil
	case sku.FieldVolume:
		m.ClearVolume()
		return nil
	case sku.FieldFirstBrokeragePrice:
		m.ClearFirstBrokeragePrice()
		return nil
	case sku.FieldSecondBrokeragePrice:
		m.ClearSecondBrokeragePrice()
		return nil
	case sku.FieldSalesCount:
		m.ClearSalesCount()
		return nil
	}
	return fmt.Errorf("unknown Sku nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkuMutation) ResetField(name string) error {
	switch name {
	case sku.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sku.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sku.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sku.FieldSpuID:
		m.ResetSpuID()
		return nil
	case sku.FieldProperties:
		m.ResetProperties()
		return nil
	case sku.FieldPrice:
		m.ResetPrice()
		return nil
	case sku.FieldMarketPrice:
		m.ResetMarketPrice()
		return nil
	case sku.FieldCostPrice:
		m.ResetCostPrice()
		return nil
	case sku.FieldBarCode:
		m.ResetBarCode()
		return nil
	case sku.FieldPicURL:
		m.ResetPicURL()
		return nil
	case sku.FieldStock:
		m.ResetStock()
		return nil
	case sku.FieldWeight:
		m.ResetWeight()
		return nil
	case sku.FieldVolume:
		m.ResetVolume()
		return nil
	case sku.FieldFirstBrokeragePrice:
		m.ResetFirstBrokeragePrice()
		return nil
	case sku.FieldSecondBrokeragePrice:
		m.ResetSecondBrokeragePrice()
		return nil
	case sku.FieldSalesCount:
		m.ResetSalesCount()
		return nil
	}
	return fmt.Errorf("unknown Sku field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.spus != nil {
		edges = append(edges, sku.EdgeSpus)
	}
	if m.comments != nil {
		edges = append(edges, sku.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sku.EdgeSpus:
		if id := m.spus; id != nil {
			return []ent.Value{*id}
		}
	case sku.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomments != nil {
		edges = append(edges, sku.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sku.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedspus {
		edges = append(edges, sku.EdgeSpus)
	}
	if m.clearedcomments {
		edges = append(edges, sku.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkuMutation) EdgeCleared(name string) bool {
	switch name {
	case sku.EdgeSpus:
		return m.clearedspus
	case sku.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkuMutation) ClearEdge(name string) error {
	switch name {
	case sku.EdgeSpus:
		m.ClearSpus()
		return nil
	}
	return fmt.Errorf("unknown Sku unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkuMutation) ResetEdge(name string) error {
	switch name {
	case sku.EdgeSpus:
		m.ResetSpus()
		return nil
	case sku.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown Sku edge %s", name)
}

// SpuMutation represents an operation that mutates the Spu nodes in the graph.
type SpuMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uint64
	created_at                     *time.Time
	updated_at                     *time.Time
	status                         *uint8
	addstatus                      *int8
	sort                           *uint32
	addsort                        *int32
	deleted_at                     *time.Time
	name                           *string
	keyword                        *string
	introduction                   *string
	description                    *string
	bar_code                       *string
	pic_url                        *string
	slider_pic_urls                *[]string
	appendslider_pic_urls          []string
	video_url                      *string
	unit                           *uint8
	addunit                        *int8
	spec_type                      *bool
	price                          *int32
	addprice                       *int32
	market_price                   *int32
	addmarket_price                *int32
	cost_price                     *int32
	addcost_price                  *int32
	stock                          *int32
	addstock                       *int32
	deliveryTemplate_id            *uint64
	adddeliveryTemplate_id         *int64
	recommend_hot                  *bool
	recommend_benefit              *bool
	recommend_best                 *bool
	recommend_new                  *bool
	recommend_good                 *bool
	give_integral                  *int32
	addgive_integral               *int32
	give_coupon_template_ids       *[]uint64
	appendgive_coupon_template_ids []uint64
	sub_commission_type            *bool
	activity_orders                *[]int32
	appendactivity_orders          []int32
	sales_count                    *int32
	addsales_count                 *int32
	virtual_sales_count            *int32
	addvirtual_sales_count         *int32
	browse_count                   *int32
	addbrowse_count                *int32
	clearedFields                  map[string]struct{}
	skus                           map[uint64]struct{}
	removedskus                    map[uint64]struct{}
	clearedskus                    bool
	brands                         *uint64
	clearedbrands                  bool
	categorys                      *uint64
	clearedcategorys               bool
	done                           bool
	oldValue                       func(context.Context) (*Spu, error)
	predicates                     []predicate.Spu
}

var _ ent.Mutation = (*SpuMutation)(nil)

// spuOption allows management of the mutation configuration using functional options.
type spuOption func(*SpuMutation)

// newSpuMutation creates new mutation for the Spu entity.
func newSpuMutation(c config, op Op, opts ...spuOption) *SpuMutation {
	m := &SpuMutation{
		config:        c,
		op:            op,
		typ:           TypeSpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpuID sets the ID field of the mutation.
func withSpuID(id uint64) spuOption {
	return func(m *SpuMutation) {
		var (
			err   error
			once  sync.Once
			value *Spu
		)
		m.oldValue = func(ctx context.Context) (*Spu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Spu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpu sets the old Spu of the mutation.
func withSpu(node *Spu) spuOption {
	return func(m *SpuMutation) {
		m.oldValue = func(context.Context) (*Spu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Spu entities.
func (m *SpuMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpuMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpuMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Spu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SpuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SpuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SpuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SpuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SpuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SpuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *SpuMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SpuMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *SpuMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SpuMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SpuMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[spu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SpuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[spu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SpuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, spu.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *SpuMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *SpuMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *SpuMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *SpuMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *SpuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SpuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SpuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SpuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[spu.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SpuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[spu.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SpuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, spu.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SpuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpuMutation) ResetName() {
	m.name = nil
}

// SetKeyword sets the "keyword" field.
func (m *SpuMutation) SetKeyword(s string) {
	m.keyword = &s
}

// Keyword returns the value of the "keyword" field in the mutation.
func (m *SpuMutation) Keyword() (r string, exists bool) {
	v := m.keyword
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyword returns the old "keyword" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldKeyword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyword: %w", err)
	}
	return oldValue.Keyword, nil
}

// ClearKeyword clears the value of the "keyword" field.
func (m *SpuMutation) ClearKeyword() {
	m.keyword = nil
	m.clearedFields[spu.FieldKeyword] = struct{}{}
}

// KeywordCleared returns if the "keyword" field was cleared in this mutation.
func (m *SpuMutation) KeywordCleared() bool {
	_, ok := m.clearedFields[spu.FieldKeyword]
	return ok
}

// ResetKeyword resets all changes to the "keyword" field.
func (m *SpuMutation) ResetKeyword() {
	m.keyword = nil
	delete(m.clearedFields, spu.FieldKeyword)
}

// SetIntroduction sets the "introduction" field.
func (m *SpuMutation) SetIntroduction(s string) {
	m.introduction = &s
}

// Introduction returns the value of the "introduction" field in the mutation.
func (m *SpuMutation) Introduction() (r string, exists bool) {
	v := m.introduction
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroduction returns the old "introduction" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldIntroduction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroduction: %w", err)
	}
	return oldValue.Introduction, nil
}

// ClearIntroduction clears the value of the "introduction" field.
func (m *SpuMutation) ClearIntroduction() {
	m.introduction = nil
	m.clearedFields[spu.FieldIntroduction] = struct{}{}
}

// IntroductionCleared returns if the "introduction" field was cleared in this mutation.
func (m *SpuMutation) IntroductionCleared() bool {
	_, ok := m.clearedFields[spu.FieldIntroduction]
	return ok
}

// ResetIntroduction resets all changes to the "introduction" field.
func (m *SpuMutation) ResetIntroduction() {
	m.introduction = nil
	delete(m.clearedFields, spu.FieldIntroduction)
}

// SetDescription sets the "description" field.
func (m *SpuMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SpuMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SpuMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[spu.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SpuMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[spu.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SpuMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, spu.FieldDescription)
}

// SetBarCode sets the "bar_code" field.
func (m *SpuMutation) SetBarCode(s string) {
	m.bar_code = &s
}

// BarCode returns the value of the "bar_code" field in the mutation.
func (m *SpuMutation) BarCode() (r string, exists bool) {
	v := m.bar_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBarCode returns the old "bar_code" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldBarCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarCode: %w", err)
	}
	return oldValue.BarCode, nil
}

// ClearBarCode clears the value of the "bar_code" field.
func (m *SpuMutation) ClearBarCode() {
	m.bar_code = nil
	m.clearedFields[spu.FieldBarCode] = struct{}{}
}

// BarCodeCleared returns if the "bar_code" field was cleared in this mutation.
func (m *SpuMutation) BarCodeCleared() bool {
	_, ok := m.clearedFields[spu.FieldBarCode]
	return ok
}

// ResetBarCode resets all changes to the "bar_code" field.
func (m *SpuMutation) ResetBarCode() {
	m.bar_code = nil
	delete(m.clearedFields, spu.FieldBarCode)
}

// SetCategoryID sets the "category_id" field.
func (m *SpuMutation) SetCategoryID(u uint64) {
	m.categorys = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *SpuMutation) CategoryID() (r uint64, exists bool) {
	v := m.categorys
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldCategoryID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *SpuMutation) ClearCategoryID() {
	m.categorys = nil
	m.clearedFields[spu.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *SpuMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[spu.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *SpuMutation) ResetCategoryID() {
	m.categorys = nil
	delete(m.clearedFields, spu.FieldCategoryID)
}

// SetBrandID sets the "brand_id" field.
func (m *SpuMutation) SetBrandID(u uint64) {
	m.brands = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *SpuMutation) BrandID() (r uint64, exists bool) {
	v := m.brands
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldBrandID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *SpuMutation) ClearBrandID() {
	m.brands = nil
	m.clearedFields[spu.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *SpuMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[spu.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *SpuMutation) ResetBrandID() {
	m.brands = nil
	delete(m.clearedFields, spu.FieldBrandID)
}

// SetPicURL sets the "pic_url" field.
func (m *SpuMutation) SetPicURL(s string) {
	m.pic_url = &s
}

// PicURL returns the value of the "pic_url" field in the mutation.
func (m *SpuMutation) PicURL() (r string, exists bool) {
	v := m.pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPicURL returns the old "pic_url" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicURL: %w", err)
	}
	return oldValue.PicURL, nil
}

// ResetPicURL resets all changes to the "pic_url" field.
func (m *SpuMutation) ResetPicURL() {
	m.pic_url = nil
}

// SetSliderPicUrls sets the "slider_pic_urls" field.
func (m *SpuMutation) SetSliderPicUrls(s []string) {
	m.slider_pic_urls = &s
	m.appendslider_pic_urls = nil
}

// SliderPicUrls returns the value of the "slider_pic_urls" field in the mutation.
func (m *SpuMutation) SliderPicUrls() (r []string, exists bool) {
	v := m.slider_pic_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldSliderPicUrls returns the old "slider_pic_urls" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSliderPicUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSliderPicUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSliderPicUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSliderPicUrls: %w", err)
	}
	return oldValue.SliderPicUrls, nil
}

// AppendSliderPicUrls adds s to the "slider_pic_urls" field.
func (m *SpuMutation) AppendSliderPicUrls(s []string) {
	m.appendslider_pic_urls = append(m.appendslider_pic_urls, s...)
}

// AppendedSliderPicUrls returns the list of values that were appended to the "slider_pic_urls" field in this mutation.
func (m *SpuMutation) AppendedSliderPicUrls() ([]string, bool) {
	if len(m.appendslider_pic_urls) == 0 {
		return nil, false
	}
	return m.appendslider_pic_urls, true
}

// ClearSliderPicUrls clears the value of the "slider_pic_urls" field.
func (m *SpuMutation) ClearSliderPicUrls() {
	m.slider_pic_urls = nil
	m.appendslider_pic_urls = nil
	m.clearedFields[spu.FieldSliderPicUrls] = struct{}{}
}

// SliderPicUrlsCleared returns if the "slider_pic_urls" field was cleared in this mutation.
func (m *SpuMutation) SliderPicUrlsCleared() bool {
	_, ok := m.clearedFields[spu.FieldSliderPicUrls]
	return ok
}

// ResetSliderPicUrls resets all changes to the "slider_pic_urls" field.
func (m *SpuMutation) ResetSliderPicUrls() {
	m.slider_pic_urls = nil
	m.appendslider_pic_urls = nil
	delete(m.clearedFields, spu.FieldSliderPicUrls)
}

// SetVideoURL sets the "video_url" field.
func (m *SpuMutation) SetVideoURL(s string) {
	m.video_url = &s
}

// VideoURL returns the value of the "video_url" field in the mutation.
func (m *SpuMutation) VideoURL() (r string, exists bool) {
	v := m.video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoURL returns the old "video_url" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoURL: %w", err)
	}
	return oldValue.VideoURL, nil
}

// ClearVideoURL clears the value of the "video_url" field.
func (m *SpuMutation) ClearVideoURL() {
	m.video_url = nil
	m.clearedFields[spu.FieldVideoURL] = struct{}{}
}

// VideoURLCleared returns if the "video_url" field was cleared in this mutation.
func (m *SpuMutation) VideoURLCleared() bool {
	_, ok := m.clearedFields[spu.FieldVideoURL]
	return ok
}

// ResetVideoURL resets all changes to the "video_url" field.
func (m *SpuMutation) ResetVideoURL() {
	m.video_url = nil
	delete(m.clearedFields, spu.FieldVideoURL)
}

// SetUnit sets the "unit" field.
func (m *SpuMutation) SetUnit(u uint8) {
	m.unit = &u
	m.addunit = nil
}

// Unit returns the value of the "unit" field in the mutation.
func (m *SpuMutation) Unit() (r uint8, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldUnit(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// AddUnit adds u to the "unit" field.
func (m *SpuMutation) AddUnit(u int8) {
	if m.addunit != nil {
		*m.addunit += u
	} else {
		m.addunit = &u
	}
}

// AddedUnit returns the value that was added to the "unit" field in this mutation.
func (m *SpuMutation) AddedUnit() (r int8, exists bool) {
	v := m.addunit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnit resets all changes to the "unit" field.
func (m *SpuMutation) ResetUnit() {
	m.unit = nil
	m.addunit = nil
}

// SetSpecType sets the "spec_type" field.
func (m *SpuMutation) SetSpecType(b bool) {
	m.spec_type = &b
}

// SpecType returns the value of the "spec_type" field in the mutation.
func (m *SpuMutation) SpecType() (r bool, exists bool) {
	v := m.spec_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecType returns the old "spec_type" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSpecType(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecType: %w", err)
	}
	return oldValue.SpecType, nil
}

// ClearSpecType clears the value of the "spec_type" field.
func (m *SpuMutation) ClearSpecType() {
	m.spec_type = nil
	m.clearedFields[spu.FieldSpecType] = struct{}{}
}

// SpecTypeCleared returns if the "spec_type" field was cleared in this mutation.
func (m *SpuMutation) SpecTypeCleared() bool {
	_, ok := m.clearedFields[spu.FieldSpecType]
	return ok
}

// ResetSpecType resets all changes to the "spec_type" field.
func (m *SpuMutation) ResetSpecType() {
	m.spec_type = nil
	delete(m.clearedFields, spu.FieldSpecType)
}

// SetPrice sets the "price" field.
func (m *SpuMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SpuMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *SpuMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SpuMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *SpuMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetMarketPrice sets the "market_price" field.
func (m *SpuMutation) SetMarketPrice(i int32) {
	m.market_price = &i
	m.addmarket_price = nil
}

// MarketPrice returns the value of the "market_price" field in the mutation.
func (m *SpuMutation) MarketPrice() (r int32, exists bool) {
	v := m.market_price
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketPrice returns the old "market_price" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldMarketPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketPrice: %w", err)
	}
	return oldValue.MarketPrice, nil
}

// AddMarketPrice adds i to the "market_price" field.
func (m *SpuMutation) AddMarketPrice(i int32) {
	if m.addmarket_price != nil {
		*m.addmarket_price += i
	} else {
		m.addmarket_price = &i
	}
}

// AddedMarketPrice returns the value that was added to the "market_price" field in this mutation.
func (m *SpuMutation) AddedMarketPrice() (r int32, exists bool) {
	v := m.addmarket_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearMarketPrice clears the value of the "market_price" field.
func (m *SpuMutation) ClearMarketPrice() {
	m.market_price = nil
	m.addmarket_price = nil
	m.clearedFields[spu.FieldMarketPrice] = struct{}{}
}

// MarketPriceCleared returns if the "market_price" field was cleared in this mutation.
func (m *SpuMutation) MarketPriceCleared() bool {
	_, ok := m.clearedFields[spu.FieldMarketPrice]
	return ok
}

// ResetMarketPrice resets all changes to the "market_price" field.
func (m *SpuMutation) ResetMarketPrice() {
	m.market_price = nil
	m.addmarket_price = nil
	delete(m.clearedFields, spu.FieldMarketPrice)
}

// SetCostPrice sets the "cost_price" field.
func (m *SpuMutation) SetCostPrice(i int32) {
	m.cost_price = &i
	m.addcost_price = nil
}

// CostPrice returns the value of the "cost_price" field in the mutation.
func (m *SpuMutation) CostPrice() (r int32, exists bool) {
	v := m.cost_price
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPrice returns the old "cost_price" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldCostPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPrice: %w", err)
	}
	return oldValue.CostPrice, nil
}

// AddCostPrice adds i to the "cost_price" field.
func (m *SpuMutation) AddCostPrice(i int32) {
	if m.addcost_price != nil {
		*m.addcost_price += i
	} else {
		m.addcost_price = &i
	}
}

// AddedCostPrice returns the value that was added to the "cost_price" field in this mutation.
func (m *SpuMutation) AddedCostPrice() (r int32, exists bool) {
	v := m.addcost_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetCostPrice resets all changes to the "cost_price" field.
func (m *SpuMutation) ResetCostPrice() {
	m.cost_price = nil
	m.addcost_price = nil
}

// SetStock sets the "stock" field.
func (m *SpuMutation) SetStock(i int32) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *SpuMutation) Stock() (r int32, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldStock(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *SpuMutation) AddStock(i int32) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *SpuMutation) AddedStock() (r int32, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *SpuMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetDeliveryTemplateID sets the "deliveryTemplate_id" field.
func (m *SpuMutation) SetDeliveryTemplateID(u uint64) {
	m.deliveryTemplate_id = &u
	m.adddeliveryTemplate_id = nil
}

// DeliveryTemplateID returns the value of the "deliveryTemplate_id" field in the mutation.
func (m *SpuMutation) DeliveryTemplateID() (r uint64, exists bool) {
	v := m.deliveryTemplate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryTemplateID returns the old "deliveryTemplate_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDeliveryTemplateID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryTemplateID: %w", err)
	}
	return oldValue.DeliveryTemplateID, nil
}

// AddDeliveryTemplateID adds u to the "deliveryTemplate_id" field.
func (m *SpuMutation) AddDeliveryTemplateID(u int64) {
	if m.adddeliveryTemplate_id != nil {
		*m.adddeliveryTemplate_id += u
	} else {
		m.adddeliveryTemplate_id = &u
	}
}

// AddedDeliveryTemplateID returns the value that was added to the "deliveryTemplate_id" field in this mutation.
func (m *SpuMutation) AddedDeliveryTemplateID() (r int64, exists bool) {
	v := m.adddeliveryTemplate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryTemplateID clears the value of the "deliveryTemplate_id" field.
func (m *SpuMutation) ClearDeliveryTemplateID() {
	m.deliveryTemplate_id = nil
	m.adddeliveryTemplate_id = nil
	m.clearedFields[spu.FieldDeliveryTemplateID] = struct{}{}
}

// DeliveryTemplateIDCleared returns if the "deliveryTemplate_id" field was cleared in this mutation.
func (m *SpuMutation) DeliveryTemplateIDCleared() bool {
	_, ok := m.clearedFields[spu.FieldDeliveryTemplateID]
	return ok
}

// ResetDeliveryTemplateID resets all changes to the "deliveryTemplate_id" field.
func (m *SpuMutation) ResetDeliveryTemplateID() {
	m.deliveryTemplate_id = nil
	m.adddeliveryTemplate_id = nil
	delete(m.clearedFields, spu.FieldDeliveryTemplateID)
}

// SetRecommendHot sets the "recommend_hot" field.
func (m *SpuMutation) SetRecommendHot(b bool) {
	m.recommend_hot = &b
}

// RecommendHot returns the value of the "recommend_hot" field in the mutation.
func (m *SpuMutation) RecommendHot() (r bool, exists bool) {
	v := m.recommend_hot
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendHot returns the old "recommend_hot" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldRecommendHot(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendHot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendHot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendHot: %w", err)
	}
	return oldValue.RecommendHot, nil
}

// ClearRecommendHot clears the value of the "recommend_hot" field.
func (m *SpuMutation) ClearRecommendHot() {
	m.recommend_hot = nil
	m.clearedFields[spu.FieldRecommendHot] = struct{}{}
}

// RecommendHotCleared returns if the "recommend_hot" field was cleared in this mutation.
func (m *SpuMutation) RecommendHotCleared() bool {
	_, ok := m.clearedFields[spu.FieldRecommendHot]
	return ok
}

// ResetRecommendHot resets all changes to the "recommend_hot" field.
func (m *SpuMutation) ResetRecommendHot() {
	m.recommend_hot = nil
	delete(m.clearedFields, spu.FieldRecommendHot)
}

// SetRecommendBenefit sets the "recommend_benefit" field.
func (m *SpuMutation) SetRecommendBenefit(b bool) {
	m.recommend_benefit = &b
}

// RecommendBenefit returns the value of the "recommend_benefit" field in the mutation.
func (m *SpuMutation) RecommendBenefit() (r bool, exists bool) {
	v := m.recommend_benefit
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendBenefit returns the old "recommend_benefit" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldRecommendBenefit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendBenefit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendBenefit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendBenefit: %w", err)
	}
	return oldValue.RecommendBenefit, nil
}

// ClearRecommendBenefit clears the value of the "recommend_benefit" field.
func (m *SpuMutation) ClearRecommendBenefit() {
	m.recommend_benefit = nil
	m.clearedFields[spu.FieldRecommendBenefit] = struct{}{}
}

// RecommendBenefitCleared returns if the "recommend_benefit" field was cleared in this mutation.
func (m *SpuMutation) RecommendBenefitCleared() bool {
	_, ok := m.clearedFields[spu.FieldRecommendBenefit]
	return ok
}

// ResetRecommendBenefit resets all changes to the "recommend_benefit" field.
func (m *SpuMutation) ResetRecommendBenefit() {
	m.recommend_benefit = nil
	delete(m.clearedFields, spu.FieldRecommendBenefit)
}

// SetRecommendBest sets the "recommend_best" field.
func (m *SpuMutation) SetRecommendBest(b bool) {
	m.recommend_best = &b
}

// RecommendBest returns the value of the "recommend_best" field in the mutation.
func (m *SpuMutation) RecommendBest() (r bool, exists bool) {
	v := m.recommend_best
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendBest returns the old "recommend_best" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldRecommendBest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendBest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendBest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendBest: %w", err)
	}
	return oldValue.RecommendBest, nil
}

// ClearRecommendBest clears the value of the "recommend_best" field.
func (m *SpuMutation) ClearRecommendBest() {
	m.recommend_best = nil
	m.clearedFields[spu.FieldRecommendBest] = struct{}{}
}

// RecommendBestCleared returns if the "recommend_best" field was cleared in this mutation.
func (m *SpuMutation) RecommendBestCleared() bool {
	_, ok := m.clearedFields[spu.FieldRecommendBest]
	return ok
}

// ResetRecommendBest resets all changes to the "recommend_best" field.
func (m *SpuMutation) ResetRecommendBest() {
	m.recommend_best = nil
	delete(m.clearedFields, spu.FieldRecommendBest)
}

// SetRecommendNew sets the "recommend_new" field.
func (m *SpuMutation) SetRecommendNew(b bool) {
	m.recommend_new = &b
}

// RecommendNew returns the value of the "recommend_new" field in the mutation.
func (m *SpuMutation) RecommendNew() (r bool, exists bool) {
	v := m.recommend_new
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendNew returns the old "recommend_new" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldRecommendNew(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendNew: %w", err)
	}
	return oldValue.RecommendNew, nil
}

// ClearRecommendNew clears the value of the "recommend_new" field.
func (m *SpuMutation) ClearRecommendNew() {
	m.recommend_new = nil
	m.clearedFields[spu.FieldRecommendNew] = struct{}{}
}

// RecommendNewCleared returns if the "recommend_new" field was cleared in this mutation.
func (m *SpuMutation) RecommendNewCleared() bool {
	_, ok := m.clearedFields[spu.FieldRecommendNew]
	return ok
}

// ResetRecommendNew resets all changes to the "recommend_new" field.
func (m *SpuMutation) ResetRecommendNew() {
	m.recommend_new = nil
	delete(m.clearedFields, spu.FieldRecommendNew)
}

// SetRecommendGood sets the "recommend_good" field.
func (m *SpuMutation) SetRecommendGood(b bool) {
	m.recommend_good = &b
}

// RecommendGood returns the value of the "recommend_good" field in the mutation.
func (m *SpuMutation) RecommendGood() (r bool, exists bool) {
	v := m.recommend_good
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendGood returns the old "recommend_good" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldRecommendGood(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendGood is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendGood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendGood: %w", err)
	}
	return oldValue.RecommendGood, nil
}

// ClearRecommendGood clears the value of the "recommend_good" field.
func (m *SpuMutation) ClearRecommendGood() {
	m.recommend_good = nil
	m.clearedFields[spu.FieldRecommendGood] = struct{}{}
}

// RecommendGoodCleared returns if the "recommend_good" field was cleared in this mutation.
func (m *SpuMutation) RecommendGoodCleared() bool {
	_, ok := m.clearedFields[spu.FieldRecommendGood]
	return ok
}

// ResetRecommendGood resets all changes to the "recommend_good" field.
func (m *SpuMutation) ResetRecommendGood() {
	m.recommend_good = nil
	delete(m.clearedFields, spu.FieldRecommendGood)
}

// SetGiveIntegral sets the "give_integral" field.
func (m *SpuMutation) SetGiveIntegral(i int32) {
	m.give_integral = &i
	m.addgive_integral = nil
}

// GiveIntegral returns the value of the "give_integral" field in the mutation.
func (m *SpuMutation) GiveIntegral() (r int32, exists bool) {
	v := m.give_integral
	if v == nil {
		return
	}
	return *v, true
}

// OldGiveIntegral returns the old "give_integral" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldGiveIntegral(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiveIntegral is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiveIntegral requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiveIntegral: %w", err)
	}
	return oldValue.GiveIntegral, nil
}

// AddGiveIntegral adds i to the "give_integral" field.
func (m *SpuMutation) AddGiveIntegral(i int32) {
	if m.addgive_integral != nil {
		*m.addgive_integral += i
	} else {
		m.addgive_integral = &i
	}
}

// AddedGiveIntegral returns the value that was added to the "give_integral" field in this mutation.
func (m *SpuMutation) AddedGiveIntegral() (r int32, exists bool) {
	v := m.addgive_integral
	if v == nil {
		return
	}
	return *v, true
}

// ClearGiveIntegral clears the value of the "give_integral" field.
func (m *SpuMutation) ClearGiveIntegral() {
	m.give_integral = nil
	m.addgive_integral = nil
	m.clearedFields[spu.FieldGiveIntegral] = struct{}{}
}

// GiveIntegralCleared returns if the "give_integral" field was cleared in this mutation.
func (m *SpuMutation) GiveIntegralCleared() bool {
	_, ok := m.clearedFields[spu.FieldGiveIntegral]
	return ok
}

// ResetGiveIntegral resets all changes to the "give_integral" field.
func (m *SpuMutation) ResetGiveIntegral() {
	m.give_integral = nil
	m.addgive_integral = nil
	delete(m.clearedFields, spu.FieldGiveIntegral)
}

// SetGiveCouponTemplateIds sets the "give_coupon_template_ids" field.
func (m *SpuMutation) SetGiveCouponTemplateIds(u []uint64) {
	m.give_coupon_template_ids = &u
	m.appendgive_coupon_template_ids = nil
}

// GiveCouponTemplateIds returns the value of the "give_coupon_template_ids" field in the mutation.
func (m *SpuMutation) GiveCouponTemplateIds() (r []uint64, exists bool) {
	v := m.give_coupon_template_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldGiveCouponTemplateIds returns the old "give_coupon_template_ids" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldGiveCouponTemplateIds(ctx context.Context) (v []uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiveCouponTemplateIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiveCouponTemplateIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiveCouponTemplateIds: %w", err)
	}
	return oldValue.GiveCouponTemplateIds, nil
}

// AppendGiveCouponTemplateIds adds u to the "give_coupon_template_ids" field.
func (m *SpuMutation) AppendGiveCouponTemplateIds(u []uint64) {
	m.appendgive_coupon_template_ids = append(m.appendgive_coupon_template_ids, u...)
}

// AppendedGiveCouponTemplateIds returns the list of values that were appended to the "give_coupon_template_ids" field in this mutation.
func (m *SpuMutation) AppendedGiveCouponTemplateIds() ([]uint64, bool) {
	if len(m.appendgive_coupon_template_ids) == 0 {
		return nil, false
	}
	return m.appendgive_coupon_template_ids, true
}

// ClearGiveCouponTemplateIds clears the value of the "give_coupon_template_ids" field.
func (m *SpuMutation) ClearGiveCouponTemplateIds() {
	m.give_coupon_template_ids = nil
	m.appendgive_coupon_template_ids = nil
	m.clearedFields[spu.FieldGiveCouponTemplateIds] = struct{}{}
}

// GiveCouponTemplateIdsCleared returns if the "give_coupon_template_ids" field was cleared in this mutation.
func (m *SpuMutation) GiveCouponTemplateIdsCleared() bool {
	_, ok := m.clearedFields[spu.FieldGiveCouponTemplateIds]
	return ok
}

// ResetGiveCouponTemplateIds resets all changes to the "give_coupon_template_ids" field.
func (m *SpuMutation) ResetGiveCouponTemplateIds() {
	m.give_coupon_template_ids = nil
	m.appendgive_coupon_template_ids = nil
	delete(m.clearedFields, spu.FieldGiveCouponTemplateIds)
}

// SetSubCommissionType sets the "sub_commission_type" field.
func (m *SpuMutation) SetSubCommissionType(b bool) {
	m.sub_commission_type = &b
}

// SubCommissionType returns the value of the "sub_commission_type" field in the mutation.
func (m *SpuMutation) SubCommissionType() (r bool, exists bool) {
	v := m.sub_commission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubCommissionType returns the old "sub_commission_type" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSubCommissionType(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubCommissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubCommissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubCommissionType: %w", err)
	}
	return oldValue.SubCommissionType, nil
}

// ClearSubCommissionType clears the value of the "sub_commission_type" field.
func (m *SpuMutation) ClearSubCommissionType() {
	m.sub_commission_type = nil
	m.clearedFields[spu.FieldSubCommissionType] = struct{}{}
}

// SubCommissionTypeCleared returns if the "sub_commission_type" field was cleared in this mutation.
func (m *SpuMutation) SubCommissionTypeCleared() bool {
	_, ok := m.clearedFields[spu.FieldSubCommissionType]
	return ok
}

// ResetSubCommissionType resets all changes to the "sub_commission_type" field.
func (m *SpuMutation) ResetSubCommissionType() {
	m.sub_commission_type = nil
	delete(m.clearedFields, spu.FieldSubCommissionType)
}

// SetActivityOrders sets the "activity_orders" field.
func (m *SpuMutation) SetActivityOrders(i []int32) {
	m.activity_orders = &i
	m.appendactivity_orders = nil
}

// ActivityOrders returns the value of the "activity_orders" field in the mutation.
func (m *SpuMutation) ActivityOrders() (r []int32, exists bool) {
	v := m.activity_orders
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityOrders returns the old "activity_orders" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldActivityOrders(ctx context.Context) (v []int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityOrders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityOrders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityOrders: %w", err)
	}
	return oldValue.ActivityOrders, nil
}

// AppendActivityOrders adds i to the "activity_orders" field.
func (m *SpuMutation) AppendActivityOrders(i []int32) {
	m.appendactivity_orders = append(m.appendactivity_orders, i...)
}

// AppendedActivityOrders returns the list of values that were appended to the "activity_orders" field in this mutation.
func (m *SpuMutation) AppendedActivityOrders() ([]int32, bool) {
	if len(m.appendactivity_orders) == 0 {
		return nil, false
	}
	return m.appendactivity_orders, true
}

// ClearActivityOrders clears the value of the "activity_orders" field.
func (m *SpuMutation) ClearActivityOrders() {
	m.activity_orders = nil
	m.appendactivity_orders = nil
	m.clearedFields[spu.FieldActivityOrders] = struct{}{}
}

// ActivityOrdersCleared returns if the "activity_orders" field was cleared in this mutation.
func (m *SpuMutation) ActivityOrdersCleared() bool {
	_, ok := m.clearedFields[spu.FieldActivityOrders]
	return ok
}

// ResetActivityOrders resets all changes to the "activity_orders" field.
func (m *SpuMutation) ResetActivityOrders() {
	m.activity_orders = nil
	m.appendactivity_orders = nil
	delete(m.clearedFields, spu.FieldActivityOrders)
}

// SetSalesCount sets the "sales_count" field.
func (m *SpuMutation) SetSalesCount(i int32) {
	m.sales_count = &i
	m.addsales_count = nil
}

// SalesCount returns the value of the "sales_count" field in the mutation.
func (m *SpuMutation) SalesCount() (r int32, exists bool) {
	v := m.sales_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesCount returns the old "sales_count" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSalesCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesCount: %w", err)
	}
	return oldValue.SalesCount, nil
}

// AddSalesCount adds i to the "sales_count" field.
func (m *SpuMutation) AddSalesCount(i int32) {
	if m.addsales_count != nil {
		*m.addsales_count += i
	} else {
		m.addsales_count = &i
	}
}

// AddedSalesCount returns the value that was added to the "sales_count" field in this mutation.
func (m *SpuMutation) AddedSalesCount() (r int32, exists bool) {
	v := m.addsales_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesCount clears the value of the "sales_count" field.
func (m *SpuMutation) ClearSalesCount() {
	m.sales_count = nil
	m.addsales_count = nil
	m.clearedFields[spu.FieldSalesCount] = struct{}{}
}

// SalesCountCleared returns if the "sales_count" field was cleared in this mutation.
func (m *SpuMutation) SalesCountCleared() bool {
	_, ok := m.clearedFields[spu.FieldSalesCount]
	return ok
}

// ResetSalesCount resets all changes to the "sales_count" field.
func (m *SpuMutation) ResetSalesCount() {
	m.sales_count = nil
	m.addsales_count = nil
	delete(m.clearedFields, spu.FieldSalesCount)
}

// SetVirtualSalesCount sets the "virtual_sales_count" field.
func (m *SpuMutation) SetVirtualSalesCount(i int32) {
	m.virtual_sales_count = &i
	m.addvirtual_sales_count = nil
}

// VirtualSalesCount returns the value of the "virtual_sales_count" field in the mutation.
func (m *SpuMutation) VirtualSalesCount() (r int32, exists bool) {
	v := m.virtual_sales_count
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualSalesCount returns the old "virtual_sales_count" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldVirtualSalesCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualSalesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualSalesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualSalesCount: %w", err)
	}
	return oldValue.VirtualSalesCount, nil
}

// AddVirtualSalesCount adds i to the "virtual_sales_count" field.
func (m *SpuMutation) AddVirtualSalesCount(i int32) {
	if m.addvirtual_sales_count != nil {
		*m.addvirtual_sales_count += i
	} else {
		m.addvirtual_sales_count = &i
	}
}

// AddedVirtualSalesCount returns the value that was added to the "virtual_sales_count" field in this mutation.
func (m *SpuMutation) AddedVirtualSalesCount() (r int32, exists bool) {
	v := m.addvirtual_sales_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearVirtualSalesCount clears the value of the "virtual_sales_count" field.
func (m *SpuMutation) ClearVirtualSalesCount() {
	m.virtual_sales_count = nil
	m.addvirtual_sales_count = nil
	m.clearedFields[spu.FieldVirtualSalesCount] = struct{}{}
}

// VirtualSalesCountCleared returns if the "virtual_sales_count" field was cleared in this mutation.
func (m *SpuMutation) VirtualSalesCountCleared() bool {
	_, ok := m.clearedFields[spu.FieldVirtualSalesCount]
	return ok
}

// ResetVirtualSalesCount resets all changes to the "virtual_sales_count" field.
func (m *SpuMutation) ResetVirtualSalesCount() {
	m.virtual_sales_count = nil
	m.addvirtual_sales_count = nil
	delete(m.clearedFields, spu.FieldVirtualSalesCount)
}

// SetBrowseCount sets the "browse_count" field.
func (m *SpuMutation) SetBrowseCount(i int32) {
	m.browse_count = &i
	m.addbrowse_count = nil
}

// BrowseCount returns the value of the "browse_count" field in the mutation.
func (m *SpuMutation) BrowseCount() (r int32, exists bool) {
	v := m.browse_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowseCount returns the old "browse_count" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldBrowseCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowseCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowseCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowseCount: %w", err)
	}
	return oldValue.BrowseCount, nil
}

// AddBrowseCount adds i to the "browse_count" field.
func (m *SpuMutation) AddBrowseCount(i int32) {
	if m.addbrowse_count != nil {
		*m.addbrowse_count += i
	} else {
		m.addbrowse_count = &i
	}
}

// AddedBrowseCount returns the value that was added to the "browse_count" field in this mutation.
func (m *SpuMutation) AddedBrowseCount() (r int32, exists bool) {
	v := m.addbrowse_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearBrowseCount clears the value of the "browse_count" field.
func (m *SpuMutation) ClearBrowseCount() {
	m.browse_count = nil
	m.addbrowse_count = nil
	m.clearedFields[spu.FieldBrowseCount] = struct{}{}
}

// BrowseCountCleared returns if the "browse_count" field was cleared in this mutation.
func (m *SpuMutation) BrowseCountCleared() bool {
	_, ok := m.clearedFields[spu.FieldBrowseCount]
	return ok
}

// ResetBrowseCount resets all changes to the "browse_count" field.
func (m *SpuMutation) ResetBrowseCount() {
	m.browse_count = nil
	m.addbrowse_count = nil
	delete(m.clearedFields, spu.FieldBrowseCount)
}

// AddSkuIDs adds the "skus" edge to the Sku entity by ids.
func (m *SpuMutation) AddSkuIDs(ids ...uint64) {
	if m.skus == nil {
		m.skus = make(map[uint64]struct{})
	}
	for i := range ids {
		m.skus[ids[i]] = struct{}{}
	}
}

// ClearSkus clears the "skus" edge to the Sku entity.
func (m *SpuMutation) ClearSkus() {
	m.clearedskus = true
}

// SkusCleared reports if the "skus" edge to the Sku entity was cleared.
func (m *SpuMutation) SkusCleared() bool {
	return m.clearedskus
}

// RemoveSkuIDs removes the "skus" edge to the Sku entity by IDs.
func (m *SpuMutation) RemoveSkuIDs(ids ...uint64) {
	if m.removedskus == nil {
		m.removedskus = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.skus, ids[i])
		m.removedskus[ids[i]] = struct{}{}
	}
}

// RemovedSkus returns the removed IDs of the "skus" edge to the Sku entity.
func (m *SpuMutation) RemovedSkusIDs() (ids []uint64) {
	for id := range m.removedskus {
		ids = append(ids, id)
	}
	return
}

// SkusIDs returns the "skus" edge IDs in the mutation.
func (m *SpuMutation) SkusIDs() (ids []uint64) {
	for id := range m.skus {
		ids = append(ids, id)
	}
	return
}

// ResetSkus resets all changes to the "skus" edge.
func (m *SpuMutation) ResetSkus() {
	m.skus = nil
	m.clearedskus = false
	m.removedskus = nil
}

// SetBrandsID sets the "brands" edge to the Brand entity by id.
func (m *SpuMutation) SetBrandsID(id uint64) {
	m.brands = &id
}

// ClearBrands clears the "brands" edge to the Brand entity.
func (m *SpuMutation) ClearBrands() {
	m.clearedbrands = true
	m.clearedFields[spu.FieldBrandID] = struct{}{}
}

// BrandsCleared reports if the "brands" edge to the Brand entity was cleared.
func (m *SpuMutation) BrandsCleared() bool {
	return m.BrandIDCleared() || m.clearedbrands
}

// BrandsID returns the "brands" edge ID in the mutation.
func (m *SpuMutation) BrandsID() (id uint64, exists bool) {
	if m.brands != nil {
		return *m.brands, true
	}
	return
}

// BrandsIDs returns the "brands" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandsID instead. It exists only for internal usage by the builders.
func (m *SpuMutation) BrandsIDs() (ids []uint64) {
	if id := m.brands; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrands resets all changes to the "brands" edge.
func (m *SpuMutation) ResetBrands() {
	m.brands = nil
	m.clearedbrands = false
}

// SetCategorysID sets the "categorys" edge to the Category entity by id.
func (m *SpuMutation) SetCategorysID(id uint64) {
	m.categorys = &id
}

// ClearCategorys clears the "categorys" edge to the Category entity.
func (m *SpuMutation) ClearCategorys() {
	m.clearedcategorys = true
	m.clearedFields[spu.FieldCategoryID] = struct{}{}
}

// CategorysCleared reports if the "categorys" edge to the Category entity was cleared.
func (m *SpuMutation) CategorysCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategorys
}

// CategorysID returns the "categorys" edge ID in the mutation.
func (m *SpuMutation) CategorysID() (id uint64, exists bool) {
	if m.categorys != nil {
		return *m.categorys, true
	}
	return
}

// CategorysIDs returns the "categorys" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategorysID instead. It exists only for internal usage by the builders.
func (m *SpuMutation) CategorysIDs() (ids []uint64) {
	if id := m.categorys; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategorys resets all changes to the "categorys" edge.
func (m *SpuMutation) ResetCategorys() {
	m.categorys = nil
	m.clearedcategorys = false
}

// Where appends a list predicates to the SpuMutation builder.
func (m *SpuMutation) Where(ps ...predicate.Spu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Spu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Spu).
func (m *SpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpuMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.created_at != nil {
		fields = append(fields, spu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, spu.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, spu.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, spu.FieldSort)
	}
	if m.deleted_at != nil {
		fields = append(fields, spu.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, spu.FieldName)
	}
	if m.keyword != nil {
		fields = append(fields, spu.FieldKeyword)
	}
	if m.introduction != nil {
		fields = append(fields, spu.FieldIntroduction)
	}
	if m.description != nil {
		fields = append(fields, spu.FieldDescription)
	}
	if m.bar_code != nil {
		fields = append(fields, spu.FieldBarCode)
	}
	if m.categorys != nil {
		fields = append(fields, spu.FieldCategoryID)
	}
	if m.brands != nil {
		fields = append(fields, spu.FieldBrandID)
	}
	if m.pic_url != nil {
		fields = append(fields, spu.FieldPicURL)
	}
	if m.slider_pic_urls != nil {
		fields = append(fields, spu.FieldSliderPicUrls)
	}
	if m.video_url != nil {
		fields = append(fields, spu.FieldVideoURL)
	}
	if m.unit != nil {
		fields = append(fields, spu.FieldUnit)
	}
	if m.spec_type != nil {
		fields = append(fields, spu.FieldSpecType)
	}
	if m.price != nil {
		fields = append(fields, spu.FieldPrice)
	}
	if m.market_price != nil {
		fields = append(fields, spu.FieldMarketPrice)
	}
	if m.cost_price != nil {
		fields = append(fields, spu.FieldCostPrice)
	}
	if m.stock != nil {
		fields = append(fields, spu.FieldStock)
	}
	if m.deliveryTemplate_id != nil {
		fields = append(fields, spu.FieldDeliveryTemplateID)
	}
	if m.recommend_hot != nil {
		fields = append(fields, spu.FieldRecommendHot)
	}
	if m.recommend_benefit != nil {
		fields = append(fields, spu.FieldRecommendBenefit)
	}
	if m.recommend_best != nil {
		fields = append(fields, spu.FieldRecommendBest)
	}
	if m.recommend_new != nil {
		fields = append(fields, spu.FieldRecommendNew)
	}
	if m.recommend_good != nil {
		fields = append(fields, spu.FieldRecommendGood)
	}
	if m.give_integral != nil {
		fields = append(fields, spu.FieldGiveIntegral)
	}
	if m.give_coupon_template_ids != nil {
		fields = append(fields, spu.FieldGiveCouponTemplateIds)
	}
	if m.sub_commission_type != nil {
		fields = append(fields, spu.FieldSubCommissionType)
	}
	if m.activity_orders != nil {
		fields = append(fields, spu.FieldActivityOrders)
	}
	if m.sales_count != nil {
		fields = append(fields, spu.FieldSalesCount)
	}
	if m.virtual_sales_count != nil {
		fields = append(fields, spu.FieldVirtualSalesCount)
	}
	if m.browse_count != nil {
		fields = append(fields, spu.FieldBrowseCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spu.FieldCreatedAt:
		return m.CreatedAt()
	case spu.FieldUpdatedAt:
		return m.UpdatedAt()
	case spu.FieldStatus:
		return m.Status()
	case spu.FieldSort:
		return m.Sort()
	case spu.FieldDeletedAt:
		return m.DeletedAt()
	case spu.FieldName:
		return m.Name()
	case spu.FieldKeyword:
		return m.Keyword()
	case spu.FieldIntroduction:
		return m.Introduction()
	case spu.FieldDescription:
		return m.Description()
	case spu.FieldBarCode:
		return m.BarCode()
	case spu.FieldCategoryID:
		return m.CategoryID()
	case spu.FieldBrandID:
		return m.BrandID()
	case spu.FieldPicURL:
		return m.PicURL()
	case spu.FieldSliderPicUrls:
		return m.SliderPicUrls()
	case spu.FieldVideoURL:
		return m.VideoURL()
	case spu.FieldUnit:
		return m.Unit()
	case spu.FieldSpecType:
		return m.SpecType()
	case spu.FieldPrice:
		return m.Price()
	case spu.FieldMarketPrice:
		return m.MarketPrice()
	case spu.FieldCostPrice:
		return m.CostPrice()
	case spu.FieldStock:
		return m.Stock()
	case spu.FieldDeliveryTemplateID:
		return m.DeliveryTemplateID()
	case spu.FieldRecommendHot:
		return m.RecommendHot()
	case spu.FieldRecommendBenefit:
		return m.RecommendBenefit()
	case spu.FieldRecommendBest:
		return m.RecommendBest()
	case spu.FieldRecommendNew:
		return m.RecommendNew()
	case spu.FieldRecommendGood:
		return m.RecommendGood()
	case spu.FieldGiveIntegral:
		return m.GiveIntegral()
	case spu.FieldGiveCouponTemplateIds:
		return m.GiveCouponTemplateIds()
	case spu.FieldSubCommissionType:
		return m.SubCommissionType()
	case spu.FieldActivityOrders:
		return m.ActivityOrders()
	case spu.FieldSalesCount:
		return m.SalesCount()
	case spu.FieldVirtualSalesCount:
		return m.VirtualSalesCount()
	case spu.FieldBrowseCount:
		return m.BrowseCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case spu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case spu.FieldStatus:
		return m.OldStatus(ctx)
	case spu.FieldSort:
		return m.OldSort(ctx)
	case spu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case spu.FieldName:
		return m.OldName(ctx)
	case spu.FieldKeyword:
		return m.OldKeyword(ctx)
	case spu.FieldIntroduction:
		return m.OldIntroduction(ctx)
	case spu.FieldDescription:
		return m.OldDescription(ctx)
	case spu.FieldBarCode:
		return m.OldBarCode(ctx)
	case spu.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case spu.FieldBrandID:
		return m.OldBrandID(ctx)
	case spu.FieldPicURL:
		return m.OldPicURL(ctx)
	case spu.FieldSliderPicUrls:
		return m.OldSliderPicUrls(ctx)
	case spu.FieldVideoURL:
		return m.OldVideoURL(ctx)
	case spu.FieldUnit:
		return m.OldUnit(ctx)
	case spu.FieldSpecType:
		return m.OldSpecType(ctx)
	case spu.FieldPrice:
		return m.OldPrice(ctx)
	case spu.FieldMarketPrice:
		return m.OldMarketPrice(ctx)
	case spu.FieldCostPrice:
		return m.OldCostPrice(ctx)
	case spu.FieldStock:
		return m.OldStock(ctx)
	case spu.FieldDeliveryTemplateID:
		return m.OldDeliveryTemplateID(ctx)
	case spu.FieldRecommendHot:
		return m.OldRecommendHot(ctx)
	case spu.FieldRecommendBenefit:
		return m.OldRecommendBenefit(ctx)
	case spu.FieldRecommendBest:
		return m.OldRecommendBest(ctx)
	case spu.FieldRecommendNew:
		return m.OldRecommendNew(ctx)
	case spu.FieldRecommendGood:
		return m.OldRecommendGood(ctx)
	case spu.FieldGiveIntegral:
		return m.OldGiveIntegral(ctx)
	case spu.FieldGiveCouponTemplateIds:
		return m.OldGiveCouponTemplateIds(ctx)
	case spu.FieldSubCommissionType:
		return m.OldSubCommissionType(ctx)
	case spu.FieldActivityOrders:
		return m.OldActivityOrders(ctx)
	case spu.FieldSalesCount:
		return m.OldSalesCount(ctx)
	case spu.FieldVirtualSalesCount:
		return m.OldVirtualSalesCount(ctx)
	case spu.FieldBrowseCount:
		return m.OldBrowseCount(ctx)
	}
	return nil, fmt.Errorf("unknown Spu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case spu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case spu.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case spu.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case spu.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case spu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case spu.FieldKeyword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyword(v)
		return nil
	case spu.FieldIntroduction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroduction(v)
		return nil
	case spu.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case spu.FieldBarCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarCode(v)
		return nil
	case spu.FieldCategoryID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case spu.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case spu.FieldPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicURL(v)
		return nil
	case spu.FieldSliderPicUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSliderPicUrls(v)
		return nil
	case spu.FieldVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoURL(v)
		return nil
	case spu.FieldUnit:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case spu.FieldSpecType:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecType(v)
		return nil
	case spu.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case spu.FieldMarketPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketPrice(v)
		return nil
	case spu.FieldCostPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPrice(v)
		return nil
	case spu.FieldStock:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case spu.FieldDeliveryTemplateID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryTemplateID(v)
		return nil
	case spu.FieldRecommendHot:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendHot(v)
		return nil
	case spu.FieldRecommendBenefit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendBenefit(v)
		return nil
	case spu.FieldRecommendBest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendBest(v)
		return nil
	case spu.FieldRecommendNew:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendNew(v)
		return nil
	case spu.FieldRecommendGood:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendGood(v)
		return nil
	case spu.FieldGiveIntegral:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiveIntegral(v)
		return nil
	case spu.FieldGiveCouponTemplateIds:
		v, ok := value.([]uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiveCouponTemplateIds(v)
		return nil
	case spu.FieldSubCommissionType:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubCommissionType(v)
		return nil
	case spu.FieldActivityOrders:
		v, ok := value.([]int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityOrders(v)
		return nil
	case spu.FieldSalesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesCount(v)
		return nil
	case spu.FieldVirtualSalesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualSalesCount(v)
		return nil
	case spu.FieldBrowseCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowseCount(v)
		return nil
	}
	return fmt.Errorf("unknown Spu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpuMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, spu.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, spu.FieldSort)
	}
	if m.addunit != nil {
		fields = append(fields, spu.FieldUnit)
	}
	if m.addprice != nil {
		fields = append(fields, spu.FieldPrice)
	}
	if m.addmarket_price != nil {
		fields = append(fields, spu.FieldMarketPrice)
	}
	if m.addcost_price != nil {
		fields = append(fields, spu.FieldCostPrice)
	}
	if m.addstock != nil {
		fields = append(fields, spu.FieldStock)
	}
	if m.adddeliveryTemplate_id != nil {
		fields = append(fields, spu.FieldDeliveryTemplateID)
	}
	if m.addgive_integral != nil {
		fields = append(fields, spu.FieldGiveIntegral)
	}
	if m.addsales_count != nil {
		fields = append(fields, spu.FieldSalesCount)
	}
	if m.addvirtual_sales_count != nil {
		fields = append(fields, spu.FieldVirtualSalesCount)
	}
	if m.addbrowse_count != nil {
		fields = append(fields, spu.FieldBrowseCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spu.FieldStatus:
		return m.AddedStatus()
	case spu.FieldSort:
		return m.AddedSort()
	case spu.FieldUnit:
		return m.AddedUnit()
	case spu.FieldPrice:
		return m.AddedPrice()
	case spu.FieldMarketPrice:
		return m.AddedMarketPrice()
	case spu.FieldCostPrice:
		return m.AddedCostPrice()
	case spu.FieldStock:
		return m.AddedStock()
	case spu.FieldDeliveryTemplateID:
		return m.AddedDeliveryTemplateID()
	case spu.FieldGiveIntegral:
		return m.AddedGiveIntegral()
	case spu.FieldSalesCount:
		return m.AddedSalesCount()
	case spu.FieldVirtualSalesCount:
		return m.AddedVirtualSalesCount()
	case spu.FieldBrowseCount:
		return m.AddedBrowseCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spu.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case spu.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case spu.FieldUnit:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnit(v)
		return nil
	case spu.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case spu.FieldMarketPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketPrice(v)
		return nil
	case spu.FieldCostPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostPrice(v)
		return nil
	case spu.FieldStock:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case spu.FieldDeliveryTemplateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryTemplateID(v)
		return nil
	case spu.FieldGiveIntegral:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiveIntegral(v)
		return nil
	case spu.FieldSalesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesCount(v)
		return nil
	case spu.FieldVirtualSalesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVirtualSalesCount(v)
		return nil
	case spu.FieldBrowseCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrowseCount(v)
		return nil
	}
	return fmt.Errorf("unknown Spu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spu.FieldStatus) {
		fields = append(fields, spu.FieldStatus)
	}
	if m.FieldCleared(spu.FieldDeletedAt) {
		fields = append(fields, spu.FieldDeletedAt)
	}
	if m.FieldCleared(spu.FieldKeyword) {
		fields = append(fields, spu.FieldKeyword)
	}
	if m.FieldCleared(spu.FieldIntroduction) {
		fields = append(fields, spu.FieldIntroduction)
	}
	if m.FieldCleared(spu.FieldDescription) {
		fields = append(fields, spu.FieldDescription)
	}
	if m.FieldCleared(spu.FieldBarCode) {
		fields = append(fields, spu.FieldBarCode)
	}
	if m.FieldCleared(spu.FieldCategoryID) {
		fields = append(fields, spu.FieldCategoryID)
	}
	if m.FieldCleared(spu.FieldBrandID) {
		fields = append(fields, spu.FieldBrandID)
	}
	if m.FieldCleared(spu.FieldSliderPicUrls) {
		fields = append(fields, spu.FieldSliderPicUrls)
	}
	if m.FieldCleared(spu.FieldVideoURL) {
		fields = append(fields, spu.FieldVideoURL)
	}
	if m.FieldCleared(spu.FieldSpecType) {
		fields = append(fields, spu.FieldSpecType)
	}
	if m.FieldCleared(spu.FieldMarketPrice) {
		fields = append(fields, spu.FieldMarketPrice)
	}
	if m.FieldCleared(spu.FieldDeliveryTemplateID) {
		fields = append(fields, spu.FieldDeliveryTemplateID)
	}
	if m.FieldCleared(spu.FieldRecommendHot) {
		fields = append(fields, spu.FieldRecommendHot)
	}
	if m.FieldCleared(spu.FieldRecommendBenefit) {
		fields = append(fields, spu.FieldRecommendBenefit)
	}
	if m.FieldCleared(spu.FieldRecommendBest) {
		fields = append(fields, spu.FieldRecommendBest)
	}
	if m.FieldCleared(spu.FieldRecommendNew) {
		fields = append(fields, spu.FieldRecommendNew)
	}
	if m.FieldCleared(spu.FieldRecommendGood) {
		fields = append(fields, spu.FieldRecommendGood)
	}
	if m.FieldCleared(spu.FieldGiveIntegral) {
		fields = append(fields, spu.FieldGiveIntegral)
	}
	if m.FieldCleared(spu.FieldGiveCouponTemplateIds) {
		fields = append(fields, spu.FieldGiveCouponTemplateIds)
	}
	if m.FieldCleared(spu.FieldSubCommissionType) {
		fields = append(fields, spu.FieldSubCommissionType)
	}
	if m.FieldCleared(spu.FieldActivityOrders) {
		fields = append(fields, spu.FieldActivityOrders)
	}
	if m.FieldCleared(spu.FieldSalesCount) {
		fields = append(fields, spu.FieldSalesCount)
	}
	if m.FieldCleared(spu.FieldVirtualSalesCount) {
		fields = append(fields, spu.FieldVirtualSalesCount)
	}
	if m.FieldCleared(spu.FieldBrowseCount) {
		fields = append(fields, spu.FieldBrowseCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpuMutation) ClearField(name string) error {
	switch name {
	case spu.FieldStatus:
		m.ClearStatus()
		return nil
	case spu.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case spu.FieldKeyword:
		m.ClearKeyword()
		return nil
	case spu.FieldIntroduction:
		m.ClearIntroduction()
		return nil
	case spu.FieldDescription:
		m.ClearDescription()
		return nil
	case spu.FieldBarCode:
		m.ClearBarCode()
		return nil
	case spu.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case spu.FieldBrandID:
		m.ClearBrandID()
		return nil
	case spu.FieldSliderPicUrls:
		m.ClearSliderPicUrls()
		return nil
	case spu.FieldVideoURL:
		m.ClearVideoURL()
		return nil
	case spu.FieldSpecType:
		m.ClearSpecType()
		return nil
	case spu.FieldMarketPrice:
		m.ClearMarketPrice()
		return nil
	case spu.FieldDeliveryTemplateID:
		m.ClearDeliveryTemplateID()
		return nil
	case spu.FieldRecommendHot:
		m.ClearRecommendHot()
		return nil
	case spu.FieldRecommendBenefit:
		m.ClearRecommendBenefit()
		return nil
	case spu.FieldRecommendBest:
		m.ClearRecommendBest()
		return nil
	case spu.FieldRecommendNew:
		m.ClearRecommendNew()
		return nil
	case spu.FieldRecommendGood:
		m.ClearRecommendGood()
		return nil
	case spu.FieldGiveIntegral:
		m.ClearGiveIntegral()
		return nil
	case spu.FieldGiveCouponTemplateIds:
		m.ClearGiveCouponTemplateIds()
		return nil
	case spu.FieldSubCommissionType:
		m.ClearSubCommissionType()
		return nil
	case spu.FieldActivityOrders:
		m.ClearActivityOrders()
		return nil
	case spu.FieldSalesCount:
		m.ClearSalesCount()
		return nil
	case spu.FieldVirtualSalesCount:
		m.ClearVirtualSalesCount()
		return nil
	case spu.FieldBrowseCount:
		m.ClearBrowseCount()
		return nil
	}
	return fmt.Errorf("unknown Spu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpuMutation) ResetField(name string) error {
	switch name {
	case spu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case spu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case spu.FieldStatus:
		m.ResetStatus()
		return nil
	case spu.FieldSort:
		m.ResetSort()
		return nil
	case spu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case spu.FieldName:
		m.ResetName()
		return nil
	case spu.FieldKeyword:
		m.ResetKeyword()
		return nil
	case spu.FieldIntroduction:
		m.ResetIntroduction()
		return nil
	case spu.FieldDescription:
		m.ResetDescription()
		return nil
	case spu.FieldBarCode:
		m.ResetBarCode()
		return nil
	case spu.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case spu.FieldBrandID:
		m.ResetBrandID()
		return nil
	case spu.FieldPicURL:
		m.ResetPicURL()
		return nil
	case spu.FieldSliderPicUrls:
		m.ResetSliderPicUrls()
		return nil
	case spu.FieldVideoURL:
		m.ResetVideoURL()
		return nil
	case spu.FieldUnit:
		m.ResetUnit()
		return nil
	case spu.FieldSpecType:
		m.ResetSpecType()
		return nil
	case spu.FieldPrice:
		m.ResetPrice()
		return nil
	case spu.FieldMarketPrice:
		m.ResetMarketPrice()
		return nil
	case spu.FieldCostPrice:
		m.ResetCostPrice()
		return nil
	case spu.FieldStock:
		m.ResetStock()
		return nil
	case spu.FieldDeliveryTemplateID:
		m.ResetDeliveryTemplateID()
		return nil
	case spu.FieldRecommendHot:
		m.ResetRecommendHot()
		return nil
	case spu.FieldRecommendBenefit:
		m.ResetRecommendBenefit()
		return nil
	case spu.FieldRecommendBest:
		m.ResetRecommendBest()
		return nil
	case spu.FieldRecommendNew:
		m.ResetRecommendNew()
		return nil
	case spu.FieldRecommendGood:
		m.ResetRecommendGood()
		return nil
	case spu.FieldGiveIntegral:
		m.ResetGiveIntegral()
		return nil
	case spu.FieldGiveCouponTemplateIds:
		m.ResetGiveCouponTemplateIds()
		return nil
	case spu.FieldSubCommissionType:
		m.ResetSubCommissionType()
		return nil
	case spu.FieldActivityOrders:
		m.ResetActivityOrders()
		return nil
	case spu.FieldSalesCount:
		m.ResetSalesCount()
		return nil
	case spu.FieldVirtualSalesCount:
		m.ResetVirtualSalesCount()
		return nil
	case spu.FieldBrowseCount:
		m.ResetBrowseCount()
		return nil
	}
	return fmt.Errorf("unknown Spu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.skus != nil {
		edges = append(edges, spu.EdgeSkus)
	}
	if m.brands != nil {
		edges = append(edges, spu.EdgeBrands)
	}
	if m.categorys != nil {
		edges = append(edges, spu.EdgeCategorys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spu.EdgeSkus:
		ids := make([]ent.Value, 0, len(m.skus))
		for id := range m.skus {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeBrands:
		if id := m.brands; id != nil {
			return []ent.Value{*id}
		}
	case spu.EdgeCategorys:
		if id := m.categorys; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedskus != nil {
		edges = append(edges, spu.EdgeSkus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case spu.EdgeSkus:
		ids := make([]ent.Value, 0, len(m.removedskus))
		for id := range m.removedskus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedskus {
		edges = append(edges, spu.EdgeSkus)
	}
	if m.clearedbrands {
		edges = append(edges, spu.EdgeBrands)
	}
	if m.clearedcategorys {
		edges = append(edges, spu.EdgeCategorys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpuMutation) EdgeCleared(name string) bool {
	switch name {
	case spu.EdgeSkus:
		return m.clearedskus
	case spu.EdgeBrands:
		return m.clearedbrands
	case spu.EdgeCategorys:
		return m.clearedcategorys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpuMutation) ClearEdge(name string) error {
	switch name {
	case spu.EdgeBrands:
		m.ClearBrands()
		return nil
	case spu.EdgeCategorys:
		m.ClearCategorys()
		return nil
	}
	return fmt.Errorf("unknown Spu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpuMutation) ResetEdge(name string) error {
	switch name {
	case spu.EdgeSkus:
		m.ResetSkus()
		return nil
	case spu.EdgeBrands:
		m.ResetBrands()
		return nil
	case spu.EdgeCategorys:
		m.ResetCategorys()
		return nil
	}
	return fmt.Errorf("unknown Spu edge %s", name)
}
